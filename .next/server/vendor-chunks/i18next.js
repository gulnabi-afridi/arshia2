"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next";
exports.ids = ["vendor-chunks/i18next"];
exports.modules = {

/***/ "(ssr)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        if (console && console[type]) console[type].apply(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (typeof args[0] === \"string\") args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            this.observers[event] = this.observers[event] || [];\n            this.observers[event].push(listener);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event] = this.observers[event].filter((l)=>l !== listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = [].concat(this.observers[event]);\n            cloned.forEach((observer)=>{\n                observer(...args);\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = [].concat(this.observers[\"*\"]);\n            cloned.forEach((observer)=>{\n                observer.apply(observer, [\n                    event,\n                    ...args\n                ]);\n            });\n        }\n    }\n}\nfunction defer() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n}\nfunction makeString(object) {\n    if (object == null) return \"\";\n    return \"\" + object;\n}\nfunction copy(a, s, t) {\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n}\nfunction getLastOfPath(object, path, Empty) {\n    function cleanKey(key) {\n        return key && key.indexOf(\"###\") > -1 ? key.replace(/###/g, \".\") : key;\n    }\n    function canNotTraverseDeeper() {\n        return !object || typeof object === \"string\";\n    }\n    const stack = typeof path !== \"string\" ? [].concat(path) : path.split(\".\");\n    while(stack.length > 1){\n        if (canNotTraverseDeeper()) return {};\n        const key = cleanKey(stack.shift());\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n    }\n    if (canNotTraverseDeeper()) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack.shift())\n    };\n}\nfunction setPath(object, path, newValue) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    if (concat) obj[k] = obj[k].concat(newValue);\n    if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (typeof target[prop] === \"string\" || target[prop] instanceof String || typeof source[prop] === \"string\" || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n}\nfunction regexEscape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nfunction escape(data) {\n    if (typeof data === \"string\") {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = new RegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n}\nfunction deepFind(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) return obj[path];\n    const paths = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < paths.length; ++i){\n        if (!current) return undefined;\n        if (typeof current[paths[i]] === \"string\" && i + 1 < paths.length) {\n            return undefined;\n        }\n        if (current[paths[i]] === undefined) {\n            let j = 2;\n            let p = paths.slice(i, i + j).join(keySeparator);\n            let mix = current[p];\n            while(mix === undefined && paths.length > i + j){\n                j++;\n                p = paths.slice(i, i + j).join(keySeparator);\n                mix = current[p];\n            }\n            if (mix === undefined) return undefined;\n            if (mix === null) return null;\n            if (path.endsWith(p)) {\n                if (typeof mix === \"string\") return mix;\n                if (p && typeof mix[p] === \"string\") return mix[p];\n            }\n            const joinedPath = paths.slice(i + j).join(keySeparator);\n            if (joinedPath) return deepFind(mix, joinedPath, keySeparator);\n            return undefined;\n        }\n        current = current[paths[i]];\n    }\n    return current;\n}\nfunction getCleanedCode(code) {\n    if (code && code.indexOf(\"_\") > 0) return code.replace(\"_\", \"-\");\n    return code;\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key && typeof key !== \"string\") path = path.concat(key);\n        if (key && typeof key === \"string\") path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        }\n        const result = getPath(this.data, path);\n        if (result || !ignoreJSONStructure || typeof key !== \"string\") return result;\n        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (typeof resources[m] === \"string\" || Object.prototype.toString.apply(resources[m]) === \"[object Array]\") this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        if (this.options.compatibilityAPI === \"v1\") return {\n            ...{},\n            ...this.getResource(lng, ns)\n        };\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key === undefined || key === null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved && resolved.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        return {\n            key,\n            namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys === undefined || keys === null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng && lng.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved && resolved.res;\n        const resUsedKey = resolved && resolved.usedKey || key;\n        const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n        const resType = Object.prototype.toString.apply(res);\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const handleAsObject = typeof res !== \"string\" && typeof res !== \"boolean\" && typeof res !== \"number\";\n        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === \"string\" && resType === \"[object Array]\")) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n                    ...options,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = resType === \"[object Array]\";\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in res){\n                    if (Object.prototype.hasOwnProperty.call(res, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        copy[m] = this.translate(deepKey, {\n                            ...options,\n                            ...{\n                                joinArrays: false,\n                                ns: namespaces\n                            }\n                        });\n                        if (copy[m] === deepKey) copy[m] = res[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && typeof joinArrays === \"string\" && resType === \"[object Array]\") {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const hasDefaultValue = Translator.hasDefaultValue(options);\n            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n            const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n                ordinal: false\n            }) : \"\";\n            const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            this.pluralResolver.getSuffixes(language, options).forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                if (this.options.compatibilityAPI !== \"v1\") {\n                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n                } else {\n                    res = this.options.parseMissingKeyHandler(res);\n                }\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat && this.i18nFormat.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = typeof res === \"string\" && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && typeof options.replace !== \"string\" ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && this.options.compatibilityAPI !== \"v1\" && resolved && resolved.res) options.lng = resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey && lastKey[0] === args[0] && !options.context) {\n                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = typeof postProcess === \"string\" ? [\n            postProcess\n        ] : postProcess;\n        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (typeof keys === \"string\") keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const needsContextHandling = options.context !== undefined && (typeof options.context === \"string\" || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && typeof options.replace !== \"string\";\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (typeof code === \"string\" && code.indexOf(\"-\") > -1) {\n            const specialCases = [\n                \"hans\",\n                \"hant\",\n                \"latn\",\n                \"cyrl\",\n                \"cans\",\n                \"mong\",\n                \"arab\"\n            ];\n            let p = code.split(\"-\");\n            if (this.options.lowerCaseLng) {\n                p = p.map((part)=>part.toLowerCase());\n            } else if (p.length === 2) {\n                p[0] = p[0].toLowerCase();\n                p[1] = p[1].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n            } else if (p.length === 3) {\n                p[0] = p[0].toLowerCase();\n                if (p[1].length === 2) p[1] = p[1].toUpperCase();\n                if (p[0] !== \"sgn\" && p[2].length === 2) p[2] = p[2].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n            }\n            return p.join(\"-\");\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (typeof fallbacks === \"string\") fallbacks = [\n            fallbacks\n        ];\n        if (Object.prototype.toString.apply(fallbacks) === \"[object Array]\") return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (typeof code === \"string\" && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (typeof code === \"string\") {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nlet sets = [\n    {\n        lngs: [\n            \"ach\",\n            \"ak\",\n            \"am\",\n            \"arn\",\n            \"br\",\n            \"fil\",\n            \"gun\",\n            \"ln\",\n            \"mfe\",\n            \"mg\",\n            \"mi\",\n            \"oc\",\n            \"pt\",\n            \"pt-BR\",\n            \"tg\",\n            \"tl\",\n            \"ti\",\n            \"tr\",\n            \"uz\",\n            \"wa\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 1\n    },\n    {\n        lngs: [\n            \"af\",\n            \"an\",\n            \"ast\",\n            \"az\",\n            \"bg\",\n            \"bn\",\n            \"ca\",\n            \"da\",\n            \"de\",\n            \"dev\",\n            \"el\",\n            \"en\",\n            \"eo\",\n            \"es\",\n            \"et\",\n            \"eu\",\n            \"fi\",\n            \"fo\",\n            \"fur\",\n            \"fy\",\n            \"gl\",\n            \"gu\",\n            \"ha\",\n            \"hi\",\n            \"hu\",\n            \"hy\",\n            \"ia\",\n            \"it\",\n            \"kk\",\n            \"kn\",\n            \"ku\",\n            \"lb\",\n            \"mai\",\n            \"ml\",\n            \"mn\",\n            \"mr\",\n            \"nah\",\n            \"nap\",\n            \"nb\",\n            \"ne\",\n            \"nl\",\n            \"nn\",\n            \"no\",\n            \"nso\",\n            \"pa\",\n            \"pap\",\n            \"pms\",\n            \"ps\",\n            \"pt-PT\",\n            \"rm\",\n            \"sco\",\n            \"se\",\n            \"si\",\n            \"so\",\n            \"son\",\n            \"sq\",\n            \"sv\",\n            \"sw\",\n            \"ta\",\n            \"te\",\n            \"tk\",\n            \"ur\",\n            \"yo\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ay\",\n            \"bo\",\n            \"cgg\",\n            \"fa\",\n            \"ht\",\n            \"id\",\n            \"ja\",\n            \"jbo\",\n            \"ka\",\n            \"km\",\n            \"ko\",\n            \"ky\",\n            \"lo\",\n            \"ms\",\n            \"sah\",\n            \"su\",\n            \"th\",\n            \"tt\",\n            \"ug\",\n            \"vi\",\n            \"wo\",\n            \"zh\"\n        ],\n        nr: [\n            1\n        ],\n        fc: 3\n    },\n    {\n        lngs: [\n            \"be\",\n            \"bs\",\n            \"cnr\",\n            \"dz\",\n            \"hr\",\n            \"ru\",\n            \"sr\",\n            \"uk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 4\n    },\n    {\n        lngs: [\n            \"ar\"\n        ],\n        nr: [\n            0,\n            1,\n            2,\n            3,\n            11,\n            100\n        ],\n        fc: 5\n    },\n    {\n        lngs: [\n            \"cs\",\n            \"sk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 6\n    },\n    {\n        lngs: [\n            \"csb\",\n            \"pl\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 7\n    },\n    {\n        lngs: [\n            \"cy\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            8\n        ],\n        fc: 8\n    },\n    {\n        lngs: [\n            \"fr\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 9\n    },\n    {\n        lngs: [\n            \"ga\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            7,\n            11\n        ],\n        fc: 10\n    },\n    {\n        lngs: [\n            \"gd\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            20\n        ],\n        fc: 11\n    },\n    {\n        lngs: [\n            \"is\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 12\n    },\n    {\n        lngs: [\n            \"jv\"\n        ],\n        nr: [\n            0,\n            1\n        ],\n        fc: 13\n    },\n    {\n        lngs: [\n            \"kw\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            4\n        ],\n        fc: 14\n    },\n    {\n        lngs: [\n            \"lt\"\n        ],\n        nr: [\n            1,\n            2,\n            10\n        ],\n        fc: 15\n    },\n    {\n        lngs: [\n            \"lv\"\n        ],\n        nr: [\n            1,\n            2,\n            0\n        ],\n        fc: 16\n    },\n    {\n        lngs: [\n            \"mk\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 17\n    },\n    {\n        lngs: [\n            \"mnk\"\n        ],\n        nr: [\n            0,\n            1,\n            2\n        ],\n        fc: 18\n    },\n    {\n        lngs: [\n            \"mt\"\n        ],\n        nr: [\n            1,\n            2,\n            11,\n            20\n        ],\n        fc: 19\n    },\n    {\n        lngs: [\n            \"or\"\n        ],\n        nr: [\n            2,\n            1\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ro\"\n        ],\n        nr: [\n            1,\n            2,\n            20\n        ],\n        fc: 20\n    },\n    {\n        lngs: [\n            \"sl\"\n        ],\n        nr: [\n            5,\n            1,\n            2,\n            3\n        ],\n        fc: 21\n    },\n    {\n        lngs: [\n            \"he\",\n            \"iw\"\n        ],\n        nr: [\n            1,\n            2,\n            20,\n            21\n        ],\n        fc: 22\n    }\n];\nlet _rulesPluralsTypes = {\n    1: function(n) {\n        return Number(n > 1);\n    },\n    2: function(n) {\n        return Number(n != 1);\n    },\n    3: function(n) {\n        return 0;\n    },\n    4: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    5: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n    },\n    6: function(n) {\n        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n    },\n    7: function(n) {\n        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    8: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n    },\n    9: function(n) {\n        return Number(n >= 2);\n    },\n    10: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n    },\n    11: function(n) {\n        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n    },\n    12: function(n) {\n        return Number(n % 10 != 1 || n % 100 == 11);\n    },\n    13: function(n) {\n        return Number(n !== 0);\n    },\n    14: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n    },\n    15: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    16: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n    },\n    17: function(n) {\n        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n    },\n    18: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n    },\n    19: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n    },\n    20: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n    },\n    21: function(n) {\n        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n    },\n    22: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n    }\n};\nconst nonIntlVersions = [\n    \"v1\",\n    \"v2\",\n    \"v3\"\n];\nconst intlVersions = [\n    \"v4\"\n];\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nfunction createRules() {\n    const rules = {};\n    sets.forEach((set)=>{\n        set.lngs.forEach((l)=>{\n            rules[l] = {\n                numbers: set.nr,\n                plurals: _rulesPluralsTypes[set.fc]\n            };\n        });\n    });\n    return rules;\n}\nclass PluralResolver {\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === \"undefined\" || !Intl.PluralRules)) {\n            this.options.compatibilityJSON = \"v3\";\n            this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\");\n        }\n        this.rules = createRules();\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.shouldUseIntlApi()) {\n            try {\n                return new Intl.PluralRules(getCleanedCode(code), {\n                    type: options.ordinal ? \"ordinal\" : \"cardinal\"\n                });\n            } catch (err) {\n                return;\n            }\n        }\n        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (this.shouldUseIntlApi()) {\n            return rule && rule.resolvedOptions().pluralCategories.length > 1;\n        }\n        return rule && rule.numbers.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (!rule) {\n            return [];\n        }\n        if (this.shouldUseIntlApi()) {\n            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n        }\n        return rule.numbers.map((number)=>this.getSuffix(code, number, options));\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            if (this.shouldUseIntlApi()) {\n                return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n            }\n            return this.getSuffixRetroCompatible(rule, count);\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return \"\";\n    }\n    getSuffixRetroCompatible(rule, count) {\n        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        let suffix = rule.numbers[idx];\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            if (suffix === 2) {\n                suffix = \"plural\";\n            } else if (suffix === 1) {\n                suffix = \"\";\n            }\n        }\n        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n        if (this.options.compatibilityJSON === \"v1\") {\n            if (suffix === 1) return \"\";\n            if (typeof suffix === \"number\") return `_plural_${suffix.toString()}`;\n            return returnSuffix();\n        } else if (this.options.compatibilityJSON === \"v2\") {\n            return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            return returnSuffix();\n        }\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n    shouldUseIntlApi() {\n        return !nonIntlVersions.includes(this.options.compatibilityJSON);\n    }\n}\nfunction deepFindWithDefaults(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && typeof key === \"string\") {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n}\nclass Interpolator {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options.interpolation && options.interpolation.format || ((value)=>value);\n        this.init(options);\n    }\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const iOpts = options.interpolation;\n        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || \"{{\";\n        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || \"}}\";\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n        this.unescapePrefix = iOpts.unescapeSuffix ? \"\" : iOpts.unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : iOpts.unescapeSuffix || \"\";\n        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || \",\";\n        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n        this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const regexpStr = `${this.prefix}(.+?)${this.suffix}`;\n        this.regexp = new RegExp(regexpStr, \"g\");\n        const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;\n        this.regexpUnescape = new RegExp(regexpUnescapeStr, \"g\");\n        const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;\n        this.nestingRegexp = new RegExp(nestingRegexpStr, \"g\");\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        function regexSafe(val) {\n            return val.replace(/\\$/g, \"$$$$\");\n        }\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = typeof temp === \"string\" ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (typeof value !== \"string\" && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        function handleHasOptions(key, inheritedOptions) {\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            delete clonedOptions.defaultValue;\n            return key;\n        }\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== \"string\" ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && typeof value !== \"string\") return value;\n            if (typeof value !== \"string\") value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nfunction parseFormatStr(formatStr) {\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (!opt) return;\n                const [key, ...rest] = opt.split(\":\");\n                const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;\n                if (val === \"false\") formatOptions[key.trim()] = false;\n                if (val === \"true\") formatOptions[key.trim()] = true;\n                if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n}\nfunction createCachedFormatter(fn) {\n    const cache = {};\n    return function invokeFormatter(val, lng, options) {\n        const key = lng + JSON.stringify(options);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n}\nclass Formatter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        const iOpts = options.interpolation;\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nfunction removePending(q, name) {\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n}\nclass Connector extends EventEmitter {\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        if (this.backend && this.backend.init) {\n            this.backend.init(services, options.backend, options);\n        }\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (data) {\n            this.store.addResourceBundle(lng, ns, data);\n        }\n        this.state[name] = err ? -1 : 2;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (typeof languages === \"string\") languages = this.languageUtils.toResolveHierarchy(languages);\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend && this.backend.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nfunction get() {\n    return {\n        debug: false,\n        initImmediate: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: function handle(args) {\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (typeof args[1] === \"string\") ret.defaultValue = args[1];\n            if (typeof args[2] === \"string\") ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    };\n}\nfunction transformOptions(options) {\n    if (typeof options.ns === \"string\") options.ns = [\n        options.ns\n    ];\n    if (typeof options.fallbackLng === \"string\") options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (typeof options.fallbackNS === \"string\") options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs && options.supportedLngs.indexOf(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    return options;\n}\nfunction noop() {}\nfunction bindMemberFunctions(inst) {\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n}\nclass I18n extends EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initImmediate) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n            if (typeof options.ns === \"string\") {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        if (this.options.compatibilityAPI !== \"v1\") {\n            this.options.interpolation = {\n                ...defOpts.interpolation,\n                ...this.options.interpolation\n            };\n        }\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        function createClassOnDemand(ClassOrObject) {\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        }\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else if (typeof Intl !== \"undefined\") {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                compatibilityJSON: this.options.compatibilityJSON,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && this.options.compatibilityAPI !== \"v1\" && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initImmediate) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = typeof language === \"string\" ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng && usedLng.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            if (this.options.preload) {\n                this.options.preload.forEach((l)=>append(l));\n            }\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = typeof lngs === \"string\" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${options.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (typeof lng === \"string\") {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        return this.translator && this.translator.translate(...arguments);\n    }\n    exists() {\n        return this.translator && this.translator.exists(...arguments);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (typeof ns === \"string\") ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"string\") lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0);\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            clone.store = new ResourceStore(this.store.data, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n                args[_key4 - 1] = arguments[_key4];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLGdCQUFnQjtJQUNwQkMsTUFBTTtJQUNOQyxLQUFJQyxJQUFJO1FBQ04sSUFBSSxDQUFDQyxNQUFNLENBQUMsT0FBT0Q7SUFDckI7SUFDQUUsTUFBS0YsSUFBSTtRQUNQLElBQUksQ0FBQ0MsTUFBTSxDQUFDLFFBQVFEO0lBQ3RCO0lBQ0FHLE9BQU1ILElBQUk7UUFDUixJQUFJLENBQUNDLE1BQU0sQ0FBQyxTQUFTRDtJQUN2QjtJQUNBQyxRQUFPSCxJQUFJLEVBQUVFLElBQUk7UUFDZixJQUFJSSxXQUFXQSxPQUFPLENBQUNOLEtBQUssRUFBRU0sT0FBTyxDQUFDTixLQUFLLENBQUNPLEtBQUssQ0FBQ0QsU0FBU0o7SUFDN0Q7QUFDRjtBQUNBLE1BQU1NO0lBQ0pDLFlBQVlDLGNBQWMsQ0FBRTtRQUMxQixJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUksQ0FBQ0csSUFBSSxDQUFDTCxnQkFBZ0JDO0lBQzVCO0lBQ0FJLEtBQUtMLGNBQWMsRUFBRTtRQUNuQixJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUksQ0FBQ0ksTUFBTSxHQUFHTCxRQUFRSyxNQUFNLElBQUk7UUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUdQLGtCQUFrQlg7UUFDaEMsSUFBSSxDQUFDWSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDTyxLQUFLLEdBQUdQLFFBQVFPLEtBQUs7SUFDNUI7SUFDQWpCLE1BQU07UUFDSixJQUFLLElBQUlrQixPQUFPUCxVQUFVQyxNQUFNLEVBQUVYLE9B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VyxTQUFTWCxjQUFjO0FBQzlDLE1BQU1DLGdCQUFnQlUsU0FBU1YsYUFBYTtBQUVpSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Fyc2hpYS8uL25vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvZXNtL2kxOG5leHQuanM/NjhlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb25zb2xlTG9nZ2VyID0ge1xuICB0eXBlOiAnbG9nZ2VyJyxcbiAgbG9nKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnbG9nJywgYXJncyk7XG4gIH0sXG4gIHdhcm4oYXJncykge1xuICAgIHRoaXMub3V0cHV0KCd3YXJuJywgYXJncyk7XG4gIH0sXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnZXJyb3InLCBhcmdzKTtcbiAgfSxcbiAgb3V0cHV0KHR5cGUsIGFyZ3MpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlW3R5cGVdKSBjb25zb2xlW3R5cGVdLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uY3JldGVMb2dnZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5pbml0KGNvbmNyZXRlTG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBpbml0KGNvbmNyZXRlTG9nZ2VyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgJ2kxOG5leHQ6JztcbiAgICB0aGlzLmxvZ2dlciA9IGNvbmNyZXRlTG9nZ2VyIHx8IGNvbnNvbGVMb2dnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgfVxuICBsb2coKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdsb2cnLCAnJywgdHJ1ZSk7XG4gIH1cbiAgd2FybigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICcnLCB0cnVlKTtcbiAgfVxuICBlcnJvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnZXJyb3InLCAnJyk7XG4gIH1cbiAgZGVwcmVjYXRlKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJ1dBUk5JTkcgREVQUkVDQVRFRDogJywgdHJ1ZSk7XG4gIH1cbiAgZm9yd2FyZChhcmdzLCBsdmwsIHByZWZpeCwgZGVidWdPbmx5KSB7XG4gICAgaWYgKGRlYnVnT25seSAmJiAhdGhpcy5kZWJ1ZykgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykgYXJnc1swXSA9IGAke3ByZWZpeH0ke3RoaXMucHJlZml4fSAke2FyZ3NbMF19YDtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJbbHZsXShhcmdzKTtcbiAgfVxuICBjcmVhdGUobW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCB7XG4gICAgICAuLi57XG4gICAgICAgIHByZWZpeDogYCR7dGhpcy5wcmVmaXh9OiR7bW9kdWxlTmFtZX06YFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNsb25lKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnM7XG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCB0aGlzLnByZWZpeDtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbn1cbnZhciBiYXNlTG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50cywgbGlzdGVuZXIpIHtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSA9IHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHJldHVybjtcbiAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbZXZlbnRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyc1tldmVudF0gPSB0aGlzLm9ic2VydmVyc1tldmVudF0uZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICB9XG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gW10uY29uY2F0KHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyKC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1snKiddKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBbXS5jb25jYXQodGhpcy5vYnNlcnZlcnNbJyonXSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnQsIC4uLmFyZ3NdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgbGV0IHJlcztcbiAgbGV0IHJlajtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXMgPSByZXNvbHZlO1xuICAgIHJlaiA9IHJlamVjdDtcbiAgfSk7XG4gIHByb21pc2UucmVzb2x2ZSA9IHJlcztcbiAgcHJvbWlzZS5yZWplY3QgPSByZWo7XG4gIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZVN0cmluZyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gJyc7XG4gIHJldHVybiAnJyArIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGNvcHkoYSwgcywgdCkge1xuICBhLmZvckVhY2gobSA9PiB7XG4gICAgaWYgKHNbbV0pIHRbbV0gPSBzW21dO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBFbXB0eSkge1xuICBmdW5jdGlvbiBjbGVhbktleShrZXkpIHtcbiAgICByZXR1cm4ga2V5ICYmIGtleS5pbmRleE9mKCcjIyMnKSA+IC0xID8ga2V5LnJlcGxhY2UoLyMjIy9nLCAnLicpIDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGNhbk5vdFRyYXZlcnNlRGVlcGVyKCkge1xuICAgIHJldHVybiAhb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnO1xuICB9XG4gIGNvbnN0IHN0YWNrID0gdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnID8gW10uY29uY2F0KHBhdGgpIDogcGF0aC5zcGxpdCgnLicpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcigpKSByZXR1cm4ge307XG4gICAgY29uc3Qga2V5ID0gY2xlYW5LZXkoc3RhY2suc2hpZnQoKSk7XG4gICAgaWYgKCFvYmplY3Rba2V5XSAmJiBFbXB0eSkgb2JqZWN0W2tleV0gPSBuZXcgRW1wdHkoKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAoY2FuTm90VHJhdmVyc2VEZWVwZXIoKSkgcmV0dXJuIHt9O1xuICByZXR1cm4ge1xuICAgIG9iajogb2JqZWN0LFxuICAgIGs6IGNsZWFuS2V5KHN0YWNrLnNoaWZ0KCkpXG4gIH07XG59XG5mdW5jdGlvbiBzZXRQYXRoKG9iamVjdCwgcGF0aCwgbmV3VmFsdWUpIHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgb2JqW2tdID0gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiBwdXNoUGF0aChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlLCBjb25jYXQpIHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgb2JqW2tdID0gb2JqW2tdIHx8IFtdO1xuICBpZiAoY29uY2F0KSBvYmpba10gPSBvYmpba10uY29uY2F0KG5ld1ZhbHVlKTtcbiAgaWYgKCFjb25jYXQpIG9ialtrXS5wdXNoKG5ld1ZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldFBhdGgob2JqZWN0LCBwYXRoKSB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgpO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG9ialtrXTtcbn1cbmZ1bmN0aW9uIGdldFBhdGhXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFBhdGgoZGF0YSwga2V5KTtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdldFBhdGgoZGVmYXVsdERhdGEsIGtleSk7XG59XG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIGlmIChwcm9wICE9PSAnX19wcm90b19fJyAmJiBwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHRhcmdldFtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygc291cmNlW3Byb3BdID09PSAnc3RyaW5nJyB8fCBzb3VyY2VbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICBpZiAob3ZlcndyaXRlKSB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcmVnZXhFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbn1cbnZhciBfZW50aXR5TWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnLyc6ICcmI3gyRjsnXG59O1xuZnVuY3Rpb24gZXNjYXBlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIHMgPT4gX2VudGl0eU1hcFtzXSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5jb25zdCBjaGFycyA9IFsnICcsICcsJywgJz8nLCAnIScsICc7J107XG5mdW5jdGlvbiBsb29rc0xpa2VPYmplY3RQYXRoKGtleSwgbnNTZXBhcmF0b3IsIGtleVNlcGFyYXRvcikge1xuICBuc1NlcGFyYXRvciA9IG5zU2VwYXJhdG9yIHx8ICcnO1xuICBrZXlTZXBhcmF0b3IgPSBrZXlTZXBhcmF0b3IgfHwgJyc7XG4gIGNvbnN0IHBvc3NpYmxlQ2hhcnMgPSBjaGFycy5maWx0ZXIoYyA9PiBuc1NlcGFyYXRvci5pbmRleE9mKGMpIDwgMCAmJiBrZXlTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDApO1xuICBpZiAocG9zc2libGVDaGFycy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBjb25zdCByID0gbmV3IFJlZ0V4cChgKCR7cG9zc2libGVDaGFycy5tYXAoYyA9PiBjID09PSAnPycgPyAnXFxcXD8nIDogYykuam9pbignfCcpfSlgKTtcbiAgbGV0IG1hdGNoZWQgPSAhci50ZXN0KGtleSk7XG4gIGlmICghbWF0Y2hlZCkge1xuICAgIGNvbnN0IGtpID0ga2V5LmluZGV4T2Yoa2V5U2VwYXJhdG9yKTtcbiAgICBpZiAoa2kgPiAwICYmICFyLnRlc3Qoa2V5LnN1YnN0cmluZygwLCBraSkpKSB7XG4gICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZWQ7XG59XG5mdW5jdGlvbiBkZWVwRmluZChvYmosIHBhdGgpIHtcbiAgbGV0IGtleVNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJy4nO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKG9ialtwYXRoXSkgcmV0dXJuIG9ialtwYXRoXTtcbiAgY29uc3QgcGF0aHMgPSBwYXRoLnNwbGl0KGtleVNlcGFyYXRvcik7XG4gIGxldCBjdXJyZW50ID0gb2JqO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFjdXJyZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgY3VycmVudFtwYXRoc1tpXV0gPT09ICdzdHJpbmcnICYmIGkgKyAxIDwgcGF0aHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFtwYXRoc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGogPSAyO1xuICAgICAgbGV0IHAgPSBwYXRocy5zbGljZShpLCBpICsgaikuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgICAgbGV0IG1peCA9IGN1cnJlbnRbcF07XG4gICAgICB3aGlsZSAobWl4ID09PSB1bmRlZmluZWQgJiYgcGF0aHMubGVuZ3RoID4gaSArIGopIHtcbiAgICAgICAgaisrO1xuICAgICAgICBwID0gcGF0aHMuc2xpY2UoaSwgaSArIGopLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICAgICAgbWl4ID0gY3VycmVudFtwXTtcbiAgICAgIH1cbiAgICAgIGlmIChtaXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGlmIChtaXggPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHBhdGguZW5kc1dpdGgocCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnKSByZXR1cm4gbWl4O1xuICAgICAgICBpZiAocCAmJiB0eXBlb2YgbWl4W3BdID09PSAnc3RyaW5nJykgcmV0dXJuIG1peFtwXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvaW5lZFBhdGggPSBwYXRocy5zbGljZShpICsgaikuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgICAgaWYgKGpvaW5lZFBhdGgpIHJldHVybiBkZWVwRmluZChtaXgsIGpvaW5lZFBhdGgsIGtleVNlcGFyYXRvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoc1tpXV07XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBnZXRDbGVhbmVkQ29kZShjb2RlKSB7XG4gIGlmIChjb2RlICYmIGNvZGUuaW5kZXhPZignXycpID4gMCkgcmV0dXJuIGNvZGUucmVwbGFjZSgnXycsICctJyk7XG4gIHJldHVybiBjb2RlO1xufVxuXG5jbGFzcyBSZXNvdXJjZVN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBuczogWyd0cmFuc2xhdGlvbiddLFxuICAgICAgZGVmYXVsdE5TOiAndHJhbnNsYXRpb24nXG4gICAgfTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhZGROYW1lc3BhY2VzKG5zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5wdXNoKG5zKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTmFtZXNwYWNlcyhucykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcHRpb25zLm5zLmluZGV4T2YobnMpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVzb3VyY2UobG5nLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3QgaWdub3JlSlNPTlN0cnVjdHVyZSA9IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlIDogdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmU7XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGguY29uY2F0KGtleSk7XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKTtcbiAgICBpZiAocmVzdWx0IHx8ICFpZ25vcmVKU09OU3RydWN0dXJlIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBkZWVwRmluZCh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW2xuZ10gJiYgdGhpcy5kYXRhW2xuZ11bbnNdLCBrZXksIGtleVNlcGFyYXRvcik7XG4gIH1cbiAgYWRkUmVzb3VyY2UobG5nLCBucywga2V5LCB2YWx1ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChrZXkpIHBhdGggPSBwYXRoLmNvbmNhdChrZXlTZXBhcmF0b3IgPyBrZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSA6IGtleSk7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgICAgdmFsdWUgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBzZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgdmFsdWUpO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCBrZXksIHZhbHVlKTtcbiAgfVxuICBhZGRSZXNvdXJjZXMobG5nLCBucywgcmVzb3VyY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2VzW21dID09PSAnc3RyaW5nJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlc291cmNlc1ttXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHRoaXMuYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dLCB7XG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIGFkZFJlc291cmNlQnVuZGxlKGxuZywgbnMsIHJlc291cmNlcywgZGVlcCwgb3ZlcndyaXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIGRlZXAgPSByZXNvdXJjZXM7XG4gICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBsZXQgcGFjayA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKSB8fCB7fTtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgZGVlcEV4dGVuZChwYWNrLCByZXNvdXJjZXMsIG92ZXJ3cml0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2sgPSB7XG4gICAgICAgIC4uLnBhY2ssXG4gICAgICAgIC4uLnJlc291cmNlc1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHBhY2spO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIHJlbW92ZVJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtsbmddW25zXTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVOYW1lc3BhY2VzKG5zKTtcbiAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCBsbmcsIG5zKTtcbiAgfVxuICBoYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucykgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSA9PT0gJ3YxJykgcmV0dXJuIHtcbiAgICAgIC4uLnt9LFxuICAgICAgLi4udGhpcy5nZXRSZXNvdXJjZShsbmcsIG5zKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucyk7XG4gIH1cbiAgZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtsbmddO1xuICB9XG4gIGhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmcpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhQnlMYW5ndWFnZShsbmcpO1xuICAgIGNvbnN0IG4gPSBkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpIHx8IFtdO1xuICAgIHJldHVybiAhIW4uZmluZCh2ID0+IGRhdGFbdl0gJiYgT2JqZWN0LmtleXMoZGF0YVt2XSkubGVuZ3RoID4gMCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxudmFyIHBvc3RQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NvcnM6IHt9LFxuICBhZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSkge1xuICAgIHRoaXMucHJvY2Vzc29yc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG4gIH0sXG4gIGhhbmRsZShwcm9jZXNzb3JzLCB2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKSB7XG4gICAgcHJvY2Vzc29ycy5mb3JFYWNoKHByb2Nlc3NvciA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0pIHZhbHVlID0gdGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0ucHJvY2Vzcyh2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbmNvbnN0IGNoZWNrZWRMb2FkZWRGb3IgPSB7fTtcbmNsYXNzIFRyYW5zbGF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIGNvcHkoWydyZXNvdXJjZVN0b3JlJywgJ2xhbmd1YWdlVXRpbHMnLCAncGx1cmFsUmVzb2x2ZXInLCAnaW50ZXJwb2xhdG9yJywgJ2JhY2tlbmRDb25uZWN0b3InLCAnaTE4bkZvcm1hdCcsICd1dGlscyddLCBzZXJ2aWNlcywgdGhpcyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCd0cmFuc2xhdG9yJyk7XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nKSB7XG4gICAgaWYgKGxuZykgdGhpcy5sYW5ndWFnZSA9IGxuZztcbiAgfVxuICBleGlzdHMoa2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGludGVycG9sYXRpb246IHt9XG4gICAgfTtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKGtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGV4dHJhY3RGcm9tS2V5KGtleSwgb3B0aW9ucykge1xuICAgIGxldCBuc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgaWYgKG5zU2VwYXJhdG9yID09PSB1bmRlZmluZWQpIG5zU2VwYXJhdG9yID0gJzonO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IG5hbWVzcGFjZXMgPSBvcHRpb25zLm5zIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgfHwgW107XG4gICAgY29uc3Qgd291bGRDaGVja0Zvck5zSW5LZXkgPSBuc1NlcGFyYXRvciAmJiBrZXkuaW5kZXhPZihuc1NlcGFyYXRvcikgPiAtMTtcbiAgICBjb25zdCBzZWVtc05hdHVyYWxMYW5ndWFnZSA9ICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgJiYgIW9wdGlvbnMua2V5U2VwYXJhdG9yICYmICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciAmJiAhb3B0aW9ucy5uc1NlcGFyYXRvciAmJiAhbG9va3NMaWtlT2JqZWN0UGF0aChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmICh3b3VsZENoZWNrRm9yTnNJbktleSAmJiAhc2VlbXNOYXR1cmFsTGFuZ3VhZ2UpIHtcbiAgICAgIGNvbnN0IG0gPSBrZXkubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZXNwYWNlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQobnNTZXBhcmF0b3IpO1xuICAgICAgaWYgKG5zU2VwYXJhdG9yICE9PSBrZXlTZXBhcmF0b3IgfHwgbnNTZXBhcmF0b3IgPT09IGtleVNlcGFyYXRvciAmJiB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihwYXJ0c1swXSkgPiAtMSkgbmFtZXNwYWNlcyA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBrZXkgPSBwYXJ0cy5qb2luKGtleVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXNcbiAgICB9O1xuICB9XG4gIHRyYW5zbGF0ZShrZXlzLCBvcHRpb25zLCBsYXN0S2V5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cyA9PT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHRpb25zLnJldHVybkRldGFpbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmV0dXJuRGV0YWlscyA6IHRoaXMub3B0aW9ucy5yZXR1cm5EZXRhaWxzO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlc1xuICAgIH0gPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2U7XG4gICAgY29uc3QgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUgPSBvcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nICYmIGxuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGNvbnN0IG5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzOiBrZXksXG4gICAgICAgICAgdXNlZEtleToga2V5LFxuICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgIHVzZWRMbmc6IGxuZyxcbiAgICAgICAgICB1c2VkTlM6IG5hbWVzcGFjZSxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXlzLCBvcHRpb25zKTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzO1xuICAgIGNvbnN0IHJlc1VzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC51c2VkS2V5IHx8IGtleTtcbiAgICBjb25zdCByZXNFeGFjdFVzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlcyk7XG4gICAgY29uc3Qgbm9PYmplY3QgPSBbJ1tvYmplY3QgTnVtYmVyXScsICdbb2JqZWN0IEZ1bmN0aW9uXScsICdbb2JqZWN0IFJlZ0V4cF0nXTtcbiAgICBjb25zdCBqb2luQXJyYXlzID0gb3B0aW9ucy5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmpvaW5BcnJheXMgOiB0aGlzLm9wdGlvbnMuam9pbkFycmF5cztcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCA9ICF0aGlzLmkxOG5Gb3JtYXQgfHwgdGhpcy5pMThuRm9ybWF0LmhhbmRsZUFzT2JqZWN0O1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0ID0gdHlwZW9mIHJlcyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHJlcyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZXMgIT09ICdudW1iZXInO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXMgJiYgaGFuZGxlQXNPYmplY3QgJiYgbm9PYmplY3QuaW5kZXhPZihyZXNUeXBlKSA8IDAgJiYgISh0eXBlb2Ygam9pbkFycmF5cyA9PT0gJ3N0cmluZycgJiYgcmVzVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXR1cm5PYmplY3RzICYmICF0aGlzLm9wdGlvbnMucmV0dXJuT2JqZWN0cykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdhY2Nlc3NpbmcgYW4gb2JqZWN0IC0gYnV0IHJldHVybk9iamVjdHMgb3B0aW9ucyBpcyBub3QgZW5hYmxlZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlciA/IHRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIocmVzVXNlZEtleSwgcmVzLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICB9KSA6IGBrZXkgJyR7a2V5fSAoJHt0aGlzLmxhbmd1YWdlfSknIHJldHVybmVkIGFuIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZy5gO1xuICAgICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmVkLnJlcyA9IHI7XG4gICAgICAgICAgcmVzb2x2ZWQudXNlZFBhcmFtcyA9IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgaWYgKGtleVNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCByZXNUeXBlSXNBcnJheSA9IHJlc1R5cGUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIGNvbnN0IGNvcHkgPSByZXNUeXBlSXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGNvbnN0IG5ld0tleVRvVXNlID0gcmVzVHlwZUlzQXJyYXkgPyByZXNFeGFjdFVzZWRLZXkgOiByZXNVc2VkS2V5O1xuICAgICAgICBmb3IgKGNvbnN0IG0gaW4gcmVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXMsIG0pKSB7XG4gICAgICAgICAgICBjb25zdCBkZWVwS2V5ID0gYCR7bmV3S2V5VG9Vc2V9JHtrZXlTZXBhcmF0b3J9JHttfWA7XG4gICAgICAgICAgICBjb3B5W21dID0gdGhpcy50cmFuc2xhdGUoZGVlcEtleSwge1xuICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29weVttXSA9PT0gZGVlcEtleSkgY29weVttXSA9IHJlc1ttXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gY29weTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmIHR5cGVvZiBqb2luQXJyYXlzID09PSAnc3RyaW5nJyAmJiByZXNUeXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXMgPSByZXMuam9pbihqb2luQXJyYXlzKTtcbiAgICAgIGlmIChyZXMpIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXlzLCBvcHRpb25zLCBsYXN0S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVzZWREZWZhdWx0ID0gZmFsc2U7XG4gICAgICBsZXQgdXNlZEtleSA9IGZhbHNlO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBoYXNEZWZhdWx0VmFsdWUgPSBUcmFuc2xhdG9yLmhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVN1ZmZpeCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpIDogJyc7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2sgPSBvcHRpb25zLm9yZGluYWwgJiYgbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0aW9ucy5jb3VudCwge1xuICAgICAgICBvcmRpbmFsOiBmYWxzZVxuICAgICAgfSkgOiAnJztcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4fWBdIHx8IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSAmJiBoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdXNlZERlZmF1bHQgPSB0cnVlO1xuICAgICAgICByZXMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChyZXMpKSB7XG4gICAgICAgIHVzZWRLZXkgPSB0cnVlO1xuICAgICAgICByZXMgPSBrZXk7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgPSBvcHRpb25zLm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBrZXlTZXBhcmF0b3I6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGZrICYmIGZrLnJlcykgdGhpcy5sb2dnZXIud2FybignU2VlbXMgdGhlIGxvYWRlZCB0cmFuc2xhdGlvbnMgd2VyZSBpbiBmbGF0IEpTT04gZm9ybWF0IGluc3RlYWQgb2YgbmVzdGVkLiBFaXRoZXIgc2V0IGtleVNlcGFyYXRvcjogZmFsc2Ugb24gaW5pdCBvciBtYWtlIHN1cmUgeW91ciB0cmFuc2xhdGlvbnMgYXJlIHB1Ymxpc2hlZCBpbiBuZXN0ZWQgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsbmdzID0gW107XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrTG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZywgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2ZhbGxiYWNrJyAmJiBmYWxsYmFja0xuZ3MgJiYgZmFsbGJhY2tMbmdzWzBdKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWxsYmFja0xuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxuZ3MucHVzaChmYWxsYmFja0xuZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IChsLCBrLCBzcGVjaWZpY0RlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRGb3JNaXNzaW5nID0gaGFzRGVmYXVsdFZhbHVlICYmIHNwZWNpZmljRGVmYXVsdFZhbHVlICE9PSByZXMgPyBzcGVjaWZpY0RlZmF1bHRWYWx1ZSA6IHJlc0Zvck1pc3Npbmc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kQ29ubmVjdG9yICYmIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeGVzKGxhbmd1YWdlLCBvcHRpb25zKS5mb3JFYWNoKHN1ZmZpeCA9PiB7XG4gICAgICAgICAgICAgICAgc2VuZChbbGFuZ3VhZ2VdLCBrZXkgKyBzdWZmaXgsIG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7c3VmZml4fWBdIHx8IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmQobG5ncywga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzID0gdGhpcy5leHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleXMsIG9wdGlvbnMsIHJlc29sdmVkLCBsYXN0S2V5KTtcbiAgICAgIGlmICh1c2VkS2V5ICYmIHJlcyA9PT0ga2V5ICYmIHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkpIHJlcyA9IGAke25hbWVzcGFjZX06JHtrZXl9YDtcbiAgICAgIGlmICgodXNlZEtleSB8fCB1c2VkRGVmYXVsdCkgJiYgdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIodGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSA/IGAke25hbWVzcGFjZX06JHtrZXl9YCA6IGtleSwgdXNlZERlZmF1bHQgPyByZXMgOiB1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgIHJlc29sdmVkLnJlcyA9IHJlcztcbiAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5LCBvcHRpb25zLCByZXNvbHZlZCwgbGFzdEtleSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQucGFyc2UpIHtcbiAgICAgIHJlcyA9IHRoaXMuaTE4bkZvcm1hdC5wYXJzZShyZXMsIHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSwgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCByZXNvbHZlZC51c2VkTlMsIHJlc29sdmVkLnVzZWRLZXksIHtcbiAgICAgICAgcmVzb2x2ZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2tpcEludGVycG9sYXRpb24pIHtcbiAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLmluaXQoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi57XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAuLi5vcHRpb25zLmludGVycG9sYXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2tpcE9uVmFyaWFibGVzID0gdHlwZW9mIHJlcyA9PT0gJ3N0cmluZycgJiYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMpO1xuICAgICAgbGV0IG5lc3RCZWY7XG4gICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgIGNvbnN0IG5iID0gcmVzLm1hdGNoKHRoaXMuaW50ZXJwb2xhdG9yLm5lc3RpbmdSZWdleHApO1xuICAgICAgICBuZXN0QmVmID0gbmIgJiYgbmIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgdHlwZW9mIG9wdGlvbnMucmVwbGFjZSAhPT0gJ3N0cmluZycgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICByZXMgPSB0aGlzLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShyZXMsIGRhdGEsIG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHRpb25zLm5lc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5sbmcgJiYgdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScgJiYgcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzKSBvcHRpb25zLmxuZyA9IHJlc29sdmVkLnVzZWRMbmc7XG4gICAgICBpZiAob3B0aW9ucy5uZXN0ICE9PSBmYWxzZSkgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IubmVzdChyZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEtleSAmJiBsYXN0S2V5WzBdID09PSBhcmdzWzBdICYmICFvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihgSXQgc2VlbXMgeW91IGFyZSBuZXN0aW5nIHJlY3Vyc2l2ZWx5IGtleTogJHthcmdzWzBdfSBpbiBrZXk6ICR7a2V5WzBdfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IucmVzZXQoKTtcbiAgICB9XG4gICAgY29uc3QgcG9zdFByb2Nlc3MgPSBvcHRpb25zLnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSB0eXBlb2YgcG9zdFByb2Nlc3MgPT09ICdzdHJpbmcnID8gW3Bvc3RQcm9jZXNzXSA6IHBvc3RQcm9jZXNzO1xuICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCAmJiByZXMgIT09IG51bGwgJiYgcG9zdFByb2Nlc3Nvck5hbWVzICYmIHBvc3RQcm9jZXNzb3JOYW1lcy5sZW5ndGggJiYgb3B0aW9ucy5hcHBseVBvc3RQcm9jZXNzb3IgIT09IGZhbHNlKSB7XG4gICAgICByZXMgPSBwb3N0UHJvY2Vzc29yLmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkID8ge1xuICAgICAgICBpMThuUmVzb2x2ZWQ6IHtcbiAgICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gOiBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXNvbHZlKGtleXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGZvdW5kO1xuICAgIGxldCB1c2VkS2V5O1xuICAgIGxldCBleGFjdFVzZWRLZXk7XG4gICAgbGV0IHVzZWRMbmc7XG4gICAgbGV0IHVzZWROUztcbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdzdHJpbmcnKSBrZXlzID0gW2tleXNdO1xuICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGssIG9wdGlvbnMpO1xuICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdGVkLmtleTtcbiAgICAgIHVzZWRLZXkgPSBrZXk7XG4gICAgICBsZXQgbmFtZXNwYWNlcyA9IGV4dHJhY3RlZC5uYW1lc3BhY2VzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja05TKSBuYW1lc3BhY2VzID0gbmFtZXNwYWNlcy5jb25jYXQodGhpcy5vcHRpb25zLmZhbGxiYWNrTlMpO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMCAmJiB0aGlzLnBsdXJhbFJlc29sdmVyLnNob3VsZFVzZUludGxBcGkoKTtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0aW9ucy5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICdudW1iZXInKSAmJiBvcHRpb25zLmNvbnRleHQgIT09ICcnO1xuICAgICAgY29uc3QgY29kZXMgPSBvcHRpb25zLmxuZ3MgPyBvcHRpb25zLmxuZ3MgOiB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UsIG9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgdXNlZE5TID0gbnM7XG4gICAgICAgIGlmICghY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSAmJiB0aGlzLnV0aWxzICYmIHRoaXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZSh1c2VkTlMpKSB7XG4gICAgICAgICAgY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2Fybihga2V5IFwiJHt1c2VkS2V5fVwiIGZvciBsYW5ndWFnZXMgXCIke2NvZGVzLmpvaW4oJywgJyl9XCIgd29uJ3QgZ2V0IHJlc29sdmVkIGFzIG5hbWVzcGFjZSBcIiR7dXNlZE5TfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgICAgdXNlZExuZyA9IGNvZGU7XG4gICAgICAgICAgY29uc3QgZmluYWxLZXlzID0gW2tleV07XG4gICAgICAgICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQuYWRkTG9va3VwS2V5cykge1xuICAgICAgICAgICAgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMoZmluYWxLZXlzLCBrZXksIGNvZGUsIG5zLCBvcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBsdXJhbFN1ZmZpeDtcbiAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSBwbHVyYWxTdWZmaXggPSB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChjb2RlLCBvcHRpb25zLmNvdW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9TdWZmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gO1xuICAgICAgICAgICAgY29uc3Qgb3JkaW5hbFByZWZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9b3JkaW5hbCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1gO1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgemVyb1N1ZmZpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWVkc0NvbnRleHRIYW5kbGluZykge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZXh0S2V5ID0gYCR7a2V5fSR7dGhpcy5vcHRpb25zLmNvbnRleHRTZXBhcmF0b3J9JHtvcHRpb25zLmNvbnRleHR9YDtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzWmVyb1N1ZmZpeExvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHplcm9TdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcG9zc2libGVLZXk7XG4gICAgICAgICAgd2hpbGUgKHBvc3NpYmxlS2V5ID0gZmluYWxLZXlzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHtcbiAgICAgICAgICAgICAgZXhhY3RVc2VkS2V5ID0gcG9zc2libGVLZXk7XG4gICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5nZXRSZXNvdXJjZShjb2RlLCBucywgcG9zc2libGVLZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzOiBmb3VuZCxcbiAgICAgIHVzZWRLZXksXG4gICAgICBleGFjdFVzZWRLZXksXG4gICAgICB1c2VkTG5nLFxuICAgICAgdXNlZE5TXG4gICAgfTtcbiAgfVxuICBpc1ZhbGlkTG9va3VwKHJlcykge1xuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuTnVsbCAmJiByZXMgPT09IG51bGwpICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyAmJiByZXMgPT09ICcnKTtcbiAgfVxuICBnZXRSZXNvdXJjZShjb2RlLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQgJiYgdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKSByZXR1cm4gdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlU3RvcmUuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0VXNlZFBhcmFtc0RldGFpbHMoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gWydkZWZhdWx0VmFsdWUnLCAnb3JkaW5hbCcsICdjb250ZXh0JywgJ3JlcGxhY2UnLCAnbG5nJywgJ2xuZ3MnLCAnZmFsbGJhY2tMbmcnLCAnbnMnLCAna2V5U2VwYXJhdG9yJywgJ25zU2VwYXJhdG9yJywgJ3JldHVybk9iamVjdHMnLCAncmV0dXJuRGV0YWlscycsICdqb2luQXJyYXlzJywgJ3Bvc3RQcm9jZXNzJywgJ2ludGVycG9sYXRpb24nXTtcbiAgICBjb25zdCB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgdHlwZW9mIG9wdGlvbnMucmVwbGFjZSAhPT0gJ3N0cmluZyc7XG4gICAgbGV0IGRhdGEgPSB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgIGlmICh1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLmNvdW50ID0gb3B0aW9ucy5jb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgc3RhdGljIGhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ2RlZmF1bHRWYWx1ZSc7XG4gICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pICYmIHByZWZpeCA9PT0gb3B0aW9uLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAmJiB1bmRlZmluZWQgIT09IG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5jbGFzcyBMYW5ndWFnZVV0aWwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN1cHBvcnRlZExuZ3MgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdsYW5ndWFnZVV0aWxzJyk7XG4gIH1cbiAgZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHJldHVybiBudWxsO1xuICAgIHAucG9wKCk7XG4gICAgaWYgKHBbcC5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpID09PSAneCcpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwLmpvaW4oJy0nKSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gY29kZTtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwWzBdKTtcbiAgfVxuICBmb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkge1xuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgJiYgY29kZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgY29uc3Qgc3BlY2lhbENhc2VzID0gWydoYW5zJywgJ2hhbnQnLCAnbGF0bicsICdjeXJsJywgJ2NhbnMnLCAnbW9uZycsICdhcmFiJ107XG4gICAgICBsZXQgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHAgPSBwLm1hcChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzcGVjaWFsQ2FzZXMuaW5kZXhPZihwWzFdLnRvTG93ZXJDYXNlKCkpID4gLTEpIHBbMV0gPSBjYXBpdGFsaXplKHBbMV0udG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzFdLmxlbmd0aCA9PT0gMikgcFsxXSA9IHBbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBbMF0gIT09ICdzZ24nICYmIHBbMl0ubGVuZ3RoID09PSAyKSBwWzJdID0gcFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsyXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzJdID0gY2FwaXRhbGl6ZShwWzJdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAuam9pbignLScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsZWFuQ29kZSB8fCB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nID8gY29kZS50b0xvd2VyQ2FzZSgpIDogY29kZTtcbiAgfVxuICBpc1N1cHBvcnRlZENvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCA9PT0gJ2xhbmd1YWdlT25seScgfHwgdGhpcy5vcHRpb25zLm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5zdXBwb3J0ZWRMbmdzIHx8ICF0aGlzLnN1cHBvcnRlZExuZ3MubGVuZ3RoIHx8IHRoaXMuc3VwcG9ydGVkTG5ncy5pbmRleE9mKGNvZGUpID4gLTE7XG4gIH1cbiAgZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGNvZGVzKSB7XG4gICAgaWYgKCFjb2RlcykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kO1xuICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgIGNvbnN0IGNsZWFuZWRMbmcgPSB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgdGhpcy5pc1N1cHBvcnRlZENvZGUoY2xlYW5lZExuZykpIGZvdW5kID0gY2xlYW5lZExuZztcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kICYmIHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKGxuZ09ubHkpID09PSAwKSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IHRoaXMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpWzBdO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBnZXRGYWxsYmFja0NvZGVzKGZhbGxiYWNrcywgY29kZSkge1xuICAgIGlmICghZmFsbGJhY2tzKSByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBmYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIGZhbGxiYWNrcyA9IGZhbGxiYWNrcyhjb2RlKTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ3N0cmluZycpIGZhbGxiYWNrcyA9IFtmYWxsYmFja3NdO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGZhbGxiYWNrcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHJldHVybiBmYWxsYmFja3M7XG4gICAgaWYgKCFjb2RlKSByZXR1cm4gZmFsbGJhY2tzLmRlZmF1bHQgfHwgW107XG4gICAgbGV0IGZvdW5kID0gZmFsbGJhY2tzW2NvZGVdO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3MuZGVmYXVsdDtcbiAgICByZXR1cm4gZm91bmQgfHwgW107XG4gIH1cbiAgdG9SZXNvbHZlSGllcmFyY2h5KGNvZGUsIGZhbGxiYWNrQ29kZSkge1xuICAgIGNvbnN0IGZhbGxiYWNrQ29kZXMgPSB0aGlzLmdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tDb2RlIHx8IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyB8fCBbXSwgY29kZSk7XG4gICAgY29uc3QgY29kZXMgPSBbXTtcbiAgICBjb25zdCBhZGRDb2RlID0gYyA9PiB7XG4gICAgICBpZiAoIWMpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShjKSkge1xuICAgICAgICBjb2Rlcy5wdXNoKGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcmVqZWN0aW5nIGxhbmd1YWdlIGNvZGUgbm90IGZvdW5kIGluIHN1cHBvcnRlZExuZ3M6ICR7Y31gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgJiYgKGNvZGUuaW5kZXhPZignLScpID4gLTEgfHwgY29kZS5pbmRleE9mKCdfJykgPiAtMSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScpIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JyAmJiB0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgIH1cbiAgICBmYWxsYmFja0NvZGVzLmZvckVhY2goZmMgPT4ge1xuICAgICAgaWYgKGNvZGVzLmluZGV4T2YoZmMpIDwgMCkgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShmYykpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2RlcztcbiAgfVxufVxuXG5sZXQgc2V0cyA9IFt7XG4gIGxuZ3M6IFsnYWNoJywgJ2FrJywgJ2FtJywgJ2FybicsICdicicsICdmaWwnLCAnZ3VuJywgJ2xuJywgJ21mZScsICdtZycsICdtaScsICdvYycsICdwdCcsICdwdC1CUicsICd0ZycsICd0bCcsICd0aScsICd0cicsICd1eicsICd3YSddLFxuICBucjogWzEsIDJdLFxuICBmYzogMVxufSwge1xuICBsbmdzOiBbJ2FmJywgJ2FuJywgJ2FzdCcsICdheicsICdiZycsICdibicsICdjYScsICdkYScsICdkZScsICdkZXYnLCAnZWwnLCAnZW4nLCAnZW8nLCAnZXMnLCAnZXQnLCAnZXUnLCAnZmknLCAnZm8nLCAnZnVyJywgJ2Z5JywgJ2dsJywgJ2d1JywgJ2hhJywgJ2hpJywgJ2h1JywgJ2h5JywgJ2lhJywgJ2l0JywgJ2trJywgJ2tuJywgJ2t1JywgJ2xiJywgJ21haScsICdtbCcsICdtbicsICdtcicsICduYWgnLCAnbmFwJywgJ25iJywgJ25lJywgJ25sJywgJ25uJywgJ25vJywgJ25zbycsICdwYScsICdwYXAnLCAncG1zJywgJ3BzJywgJ3B0LVBUJywgJ3JtJywgJ3NjbycsICdzZScsICdzaScsICdzbycsICdzb24nLCAnc3EnLCAnc3YnLCAnc3cnLCAndGEnLCAndGUnLCAndGsnLCAndXInLCAneW8nXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDJcbn0sIHtcbiAgbG5nczogWydheScsICdibycsICdjZ2cnLCAnZmEnLCAnaHQnLCAnaWQnLCAnamEnLCAnamJvJywgJ2thJywgJ2ttJywgJ2tvJywgJ2t5JywgJ2xvJywgJ21zJywgJ3NhaCcsICdzdScsICd0aCcsICd0dCcsICd1ZycsICd2aScsICd3bycsICd6aCddLFxuICBucjogWzFdLFxuICBmYzogM1xufSwge1xuICBsbmdzOiBbJ2JlJywgJ2JzJywgJ2NucicsICdkeicsICdocicsICdydScsICdzcicsICd1ayddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogNFxufSwge1xuICBsbmdzOiBbJ2FyJ10sXG4gIG5yOiBbMCwgMSwgMiwgMywgMTEsIDEwMF0sXG4gIGZjOiA1XG59LCB7XG4gIGxuZ3M6IFsnY3MnLCAnc2snXSxcbiAgbnI6IFsxLCAyLCA1XSxcbiAgZmM6IDZcbn0sIHtcbiAgbG5nczogWydjc2InLCAncGwnXSxcbiAgbnI6IFsxLCAyLCA1XSxcbiAgZmM6IDdcbn0sIHtcbiAgbG5nczogWydjeSddLFxuICBucjogWzEsIDIsIDMsIDhdLFxuICBmYzogOFxufSwge1xuICBsbmdzOiBbJ2ZyJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiA5XG59LCB7XG4gIGxuZ3M6IFsnZ2EnXSxcbiAgbnI6IFsxLCAyLCAzLCA3LCAxMV0sXG4gIGZjOiAxMFxufSwge1xuICBsbmdzOiBbJ2dkJ10sXG4gIG5yOiBbMSwgMiwgMywgMjBdLFxuICBmYzogMTFcbn0sIHtcbiAgbG5nczogWydpcyddLFxuICBucjogWzEsIDJdLFxuICBmYzogMTJcbn0sIHtcbiAgbG5nczogWydqdiddLFxuICBucjogWzAsIDFdLFxuICBmYzogMTNcbn0sIHtcbiAgbG5nczogWydrdyddLFxuICBucjogWzEsIDIsIDMsIDRdLFxuICBmYzogMTRcbn0sIHtcbiAgbG5nczogWydsdCddLFxuICBucjogWzEsIDIsIDEwXSxcbiAgZmM6IDE1XG59LCB7XG4gIGxuZ3M6IFsnbHYnXSxcbiAgbnI6IFsxLCAyLCAwXSxcbiAgZmM6IDE2XG59LCB7XG4gIGxuZ3M6IFsnbWsnXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDE3XG59LCB7XG4gIGxuZ3M6IFsnbW5rJ10sXG4gIG5yOiBbMCwgMSwgMl0sXG4gIGZjOiAxOFxufSwge1xuICBsbmdzOiBbJ210J10sXG4gIG5yOiBbMSwgMiwgMTEsIDIwXSxcbiAgZmM6IDE5XG59LCB7XG4gIGxuZ3M6IFsnb3InXSxcbiAgbnI6IFsyLCAxXSxcbiAgZmM6IDJcbn0sIHtcbiAgbG5nczogWydybyddLFxuICBucjogWzEsIDIsIDIwXSxcbiAgZmM6IDIwXG59LCB7XG4gIGxuZ3M6IFsnc2wnXSxcbiAgbnI6IFs1LCAxLCAyLCAzXSxcbiAgZmM6IDIxXG59LCB7XG4gIGxuZ3M6IFsnaGUnLCAnaXcnXSxcbiAgbnI6IFsxLCAyLCAyMCwgMjFdLFxuICBmYzogMjJcbn1dO1xubGV0IF9ydWxlc1BsdXJhbHNUeXBlcyA9IHtcbiAgMTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPiAxKTtcbiAgfSxcbiAgMjogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gIT0gMSk7XG4gIH0sXG4gIDM6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIDQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMik7XG4gIH0sXG4gIDU6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDAgPyAwIDogbiA9PSAxID8gMSA6IG4gPT0gMiA/IDIgOiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCA/IDMgOiBuICUgMTAwID49IDExID8gNCA6IDUpO1xuICB9LFxuICA2OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPj0gMiAmJiBuIDw9IDQgPyAxIDogMik7XG4gIH0sXG4gIDc6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgODogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiAhPSA4ICYmIG4gIT0gMTEgPyAyIDogMyk7XG4gIH0sXG4gIDk6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID49IDIpO1xuICB9LFxuICAxMDogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiA8IDcgPyAyIDogbiA8IDExID8gMyA6IDQpO1xuICB9LFxuICAxMTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSB8fCBuID09IDExID8gMCA6IG4gPT0gMiB8fCBuID09IDEyID8gMSA6IG4gPiAyICYmIG4gPCAyMCA/IDIgOiAzKTtcbiAgfSxcbiAgMTI6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgIT0gMSB8fCBuICUgMTAwID09IDExKTtcbiAgfSxcbiAgMTM6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICE9PSAwKTtcbiAgfSxcbiAgMTQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPT0gMyA/IDIgOiAzKTtcbiAgfSxcbiAgMTU6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IG4gJSAxMCA+PSAyICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMik7XG4gIH0sXG4gIDE2OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICE9PSAwID8gMSA6IDIpO1xuICB9LFxuICAxNzogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSB8fCBuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IDEpO1xuICB9LFxuICAxODogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMCA/IDAgOiBuID09IDEgPyAxIDogMik7XG4gIH0sXG4gIDE5OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMCB8fCBuICUgMTAwID4gMSAmJiBuICUgMTAwIDwgMTEgPyAxIDogbiAlIDEwMCA+IDEwICYmIG4gJSAxMDAgPCAyMCA/IDIgOiAzKTtcbiAgfSxcbiAgMjA6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAwIHx8IG4gJSAxMDAgPiAwICYmIG4gJSAxMDAgPCAyMCA/IDEgOiAyKTtcbiAgfSxcbiAgMjE6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAwID09IDEgPyAxIDogbiAlIDEwMCA9PSAyID8gMiA6IG4gJSAxMDAgPT0gMyB8fCBuICUgMTAwID09IDQgPyAzIDogMCk7XG4gIH0sXG4gIDIyOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMiA/IDEgOiAobiA8IDAgfHwgbiA+IDEwKSAmJiBuICUgMTAgPT0gMCA/IDIgOiAzKTtcbiAgfVxufTtcbmNvbnN0IG5vbkludGxWZXJzaW9ucyA9IFsndjEnLCAndjInLCAndjMnXTtcbmNvbnN0IGludGxWZXJzaW9ucyA9IFsndjQnXTtcbmNvbnN0IHN1ZmZpeGVzT3JkZXIgPSB7XG4gIHplcm86IDAsXG4gIG9uZTogMSxcbiAgdHdvOiAyLFxuICBmZXc6IDMsXG4gIG1hbnk6IDQsXG4gIG90aGVyOiA1XG59O1xuZnVuY3Rpb24gY3JlYXRlUnVsZXMoKSB7XG4gIGNvbnN0IHJ1bGVzID0ge307XG4gIHNldHMuZm9yRWFjaChzZXQgPT4ge1xuICAgIHNldC5sbmdzLmZvckVhY2gobCA9PiB7XG4gICAgICBydWxlc1tsXSA9IHtcbiAgICAgICAgbnVtYmVyczogc2V0Lm5yLFxuICAgICAgICBwbHVyYWxzOiBfcnVsZXNQbHVyYWxzVHlwZXNbc2V0LmZjXVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBydWxlcztcbn1cbmNsYXNzIFBsdXJhbFJlc29sdmVyIHtcbiAgY29uc3RydWN0b3IobGFuZ3VhZ2VVdGlscykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBsYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgncGx1cmFsUmVzb2x2ZXInKTtcbiAgICBpZiAoKCF0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gfHwgaW50bFZlcnNpb25zLmluY2x1ZGVzKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTikpICYmICh0eXBlb2YgSW50bCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUludGwuUGx1cmFsUnVsZXMpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPSAndjMnO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1lvdXIgZW52aXJvbm1lbnQgc2VlbXMgbm90IHRvIGJlIEludGwgQVBJIGNvbXBhdGlibGUsIHVzZSBhbiBJbnRsLlBsdXJhbFJ1bGVzIHBvbHlmaWxsLiBXaWxsIGZhbGxiYWNrIHRvIHRoZSBjb21wYXRpYmlsaXR5SlNPTiB2MyBmb3JtYXQgaGFuZGxpbmcuJyk7XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSBjcmVhdGVSdWxlcygpO1xuICB9XG4gIGFkZFJ1bGUobG5nLCBvYmopIHtcbiAgICB0aGlzLnJ1bGVzW2xuZ10gPSBvYmo7XG4gIH1cbiAgZ2V0UnVsZShjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLlBsdXJhbFJ1bGVzKGdldENsZWFuZWRDb2RlKGNvZGUpLCB7XG4gICAgICAgICAgdHlwZTogb3B0aW9ucy5vcmRpbmFsID8gJ29yZGluYWwnIDogJ2NhcmRpbmFsJ1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJ1bGVzW2NvZGVdIHx8IHRoaXMucnVsZXNbdGhpcy5sYW5ndWFnZVV0aWxzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpXTtcbiAgfVxuICBuZWVkc1BsdXJhbChjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICByZXR1cm4gcnVsZSAmJiBydWxlLnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGUgJiYgcnVsZS5udW1iZXJzLmxlbmd0aCA+IDE7XG4gIH1cbiAgZ2V0UGx1cmFsRm9ybXNPZktleShjb2RlLCBrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4ZXMoY29kZSwgb3B0aW9ucykubWFwKHN1ZmZpeCA9PiBgJHtrZXl9JHtzdWZmaXh9YCk7XG4gIH1cbiAgZ2V0U3VmZml4ZXMoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHJldHVybiBydWxlLnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMuc29ydCgocGx1cmFsQ2F0ZWdvcnkxLCBwbHVyYWxDYXRlZ29yeTIpID0+IHN1ZmZpeGVzT3JkZXJbcGx1cmFsQ2F0ZWdvcnkxXSAtIHN1ZmZpeGVzT3JkZXJbcGx1cmFsQ2F0ZWdvcnkyXSkubWFwKHBsdXJhbENhdGVnb3J5ID0+IGAke3RoaXMub3B0aW9ucy5wcmVwZW5kfSR7b3B0aW9ucy5vcmRpbmFsID8gYG9yZGluYWwke3RoaXMub3B0aW9ucy5wcmVwZW5kfWAgOiAnJ30ke3BsdXJhbENhdGVnb3J5fWApO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZS5udW1iZXJzLm1hcChudW1iZXIgPT4gdGhpcy5nZXRTdWZmaXgoY29kZSwgbnVtYmVyLCBvcHRpb25zKSk7XG4gIH1cbiAgZ2V0U3VmZml4KGNvZGUsIGNvdW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cnVsZS5zZWxlY3QoY291bnQpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdWZmaXhSZXRyb0NvbXBhdGlibGUocnVsZSwgY291bnQpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci53YXJuKGBubyBwbHVyYWwgcnVsZSBmb3VuZCBmb3I6ICR7Y29kZX1gKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlKHJ1bGUsIGNvdW50KSB7XG4gICAgY29uc3QgaWR4ID0gcnVsZS5ub0FicyA/IHJ1bGUucGx1cmFscyhjb3VudCkgOiBydWxlLnBsdXJhbHMoTWF0aC5hYnMoY291bnQpKTtcbiAgICBsZXQgc3VmZml4ID0gcnVsZS5udW1iZXJzW2lkeF07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeCAmJiBydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgaWYgKHN1ZmZpeCA9PT0gMikge1xuICAgICAgICBzdWZmaXggPSAncGx1cmFsJztcbiAgICAgIH0gZWxzZSBpZiAoc3VmZml4ID09PSAxKSB7XG4gICAgICAgIHN1ZmZpeCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXR1cm5TdWZmaXggPSAoKSA9PiB0aGlzLm9wdGlvbnMucHJlcGVuZCAmJiBzdWZmaXgudG9TdHJpbmcoKSA/IHRoaXMub3B0aW9ucy5wcmVwZW5kICsgc3VmZml4LnRvU3RyaW5nKCkgOiBzdWZmaXgudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OID09PSAndjEnKSB7XG4gICAgICBpZiAoc3VmZml4ID09PSAxKSByZXR1cm4gJyc7XG4gICAgICBpZiAodHlwZW9mIHN1ZmZpeCA9PT0gJ251bWJlcicpIHJldHVybiBgX3BsdXJhbF8ke3N1ZmZpeC50b1N0cmluZygpfWA7XG4gICAgICByZXR1cm4gcmV0dXJuU3VmZml4KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MicpIHtcbiAgICAgIHJldHVybiByZXR1cm5TdWZmaXgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeCAmJiBydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJldHVyblN1ZmZpeCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByZXBlbmQgJiYgaWR4LnRvU3RyaW5nKCkgPyB0aGlzLm9wdGlvbnMucHJlcGVuZCArIGlkeC50b1N0cmluZygpIDogaWR4LnRvU3RyaW5nKCk7XG4gIH1cbiAgc2hvdWxkVXNlSW50bEFwaSgpIHtcbiAgICByZXR1cm4gIW5vbkludGxWZXJzaW9ucy5pbmNsdWRlcyh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpIHtcbiAgbGV0IGtleVNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJy4nO1xuICBsZXQgaWdub3JlSlNPTlN0cnVjdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgbGV0IHBhdGggPSBnZXRQYXRoV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpO1xuICBpZiAoIXBhdGggJiYgaWdub3JlSlNPTlN0cnVjdHVyZSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBkZWVwRmluZChkYXRhLCBrZXksIGtleVNlcGFyYXRvcik7XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgcGF0aCA9IGRlZXBGaW5kKGRlZmF1bHREYXRhLCBrZXksIGtleVNlcGFyYXRvcik7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5jbGFzcyBJbnRlcnBvbGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnaW50ZXJwb2xhdG9yJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiBvcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0IHx8ICh2YWx1ZSA9PiB2YWx1ZSk7XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICghb3B0aW9ucy5pbnRlcnBvbGF0aW9uKSBvcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICBlc2NhcGVWYWx1ZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgaU9wdHMgPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5lc2NhcGUgPSBpT3B0cy5lc2NhcGUgIT09IHVuZGVmaW5lZCA/IGlPcHRzLmVzY2FwZSA6IGVzY2FwZTtcbiAgICB0aGlzLmVzY2FwZVZhbHVlID0gaU9wdHMuZXNjYXBlVmFsdWUgIT09IHVuZGVmaW5lZCA/IGlPcHRzLmVzY2FwZVZhbHVlIDogdHJ1ZTtcbiAgICB0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUgPSBpT3B0cy51c2VSYXdWYWx1ZVRvRXNjYXBlICE9PSB1bmRlZmluZWQgPyBpT3B0cy51c2VSYXdWYWx1ZVRvRXNjYXBlIDogZmFsc2U7XG4gICAgdGhpcy5wcmVmaXggPSBpT3B0cy5wcmVmaXggPyByZWdleEVzY2FwZShpT3B0cy5wcmVmaXgpIDogaU9wdHMucHJlZml4RXNjYXBlZCB8fCAne3snO1xuICAgIHRoaXMuc3VmZml4ID0gaU9wdHMuc3VmZml4ID8gcmVnZXhFc2NhcGUoaU9wdHMuc3VmZml4KSA6IGlPcHRzLnN1ZmZpeEVzY2FwZWQgfHwgJ319JztcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IGlPcHRzLmZvcm1hdFNlcGFyYXRvciA/IGlPcHRzLmZvcm1hdFNlcGFyYXRvciA6IGlPcHRzLmZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy51bmVzY2FwZVByZWZpeCA9IGlPcHRzLnVuZXNjYXBlU3VmZml4ID8gJycgOiBpT3B0cy51bmVzY2FwZVByZWZpeCB8fCAnLSc7XG4gICAgdGhpcy51bmVzY2FwZVN1ZmZpeCA9IHRoaXMudW5lc2NhcGVQcmVmaXggPyAnJyA6IGlPcHRzLnVuZXNjYXBlU3VmZml4IHx8ICcnO1xuICAgIHRoaXMubmVzdGluZ1ByZWZpeCA9IGlPcHRzLm5lc3RpbmdQcmVmaXggPyByZWdleEVzY2FwZShpT3B0cy5uZXN0aW5nUHJlZml4KSA6IGlPcHRzLm5lc3RpbmdQcmVmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCckdCgnKTtcbiAgICB0aGlzLm5lc3RpbmdTdWZmaXggPSBpT3B0cy5uZXN0aW5nU3VmZml4ID8gcmVnZXhFc2NhcGUoaU9wdHMubmVzdGluZ1N1ZmZpeCkgOiBpT3B0cy5uZXN0aW5nU3VmZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnKScpO1xuICAgIHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgPSBpT3B0cy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvciA/IGlPcHRzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIDogaU9wdHMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMubWF4UmVwbGFjZXMgPSBpT3B0cy5tYXhSZXBsYWNlcyA/IGlPcHRzLm1heFJlcGxhY2VzIDogMTAwMDtcbiAgICB0aGlzLmFsd2F5c0Zvcm1hdCA9IGlPcHRzLmFsd2F5c0Zvcm1hdCAhPT0gdW5kZWZpbmVkID8gaU9wdHMuYWx3YXlzRm9ybWF0IDogZmFsc2U7XG4gICAgdGhpcy5yZXNldFJlZ0V4cCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIHJlc2V0UmVnRXhwKCkge1xuICAgIGNvbnN0IHJlZ2V4cFN0ciA9IGAke3RoaXMucHJlZml4fSguKz8pJHt0aGlzLnN1ZmZpeH1gO1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleHBTdHIsICdnJyk7XG4gICAgY29uc3QgcmVnZXhwVW5lc2NhcGVTdHIgPSBgJHt0aGlzLnByZWZpeH0ke3RoaXMudW5lc2NhcGVQcmVmaXh9KC4rPykke3RoaXMudW5lc2NhcGVTdWZmaXh9JHt0aGlzLnN1ZmZpeH1gO1xuICAgIHRoaXMucmVnZXhwVW5lc2NhcGUgPSBuZXcgUmVnRXhwKHJlZ2V4cFVuZXNjYXBlU3RyLCAnZycpO1xuICAgIGNvbnN0IG5lc3RpbmdSZWdleHBTdHIgPSBgJHt0aGlzLm5lc3RpbmdQcmVmaXh9KC4rPykke3RoaXMubmVzdGluZ1N1ZmZpeH1gO1xuICAgIHRoaXMubmVzdGluZ1JlZ2V4cCA9IG5ldyBSZWdFeHAobmVzdGluZ1JlZ2V4cFN0ciwgJ2cnKTtcbiAgfVxuICBpbnRlcnBvbGF0ZShzdHIsIGRhdGEsIGxuZywgb3B0aW9ucykge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IHJlcGxhY2VzO1xuICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMgfHwge307XG4gICAgZnVuY3Rpb24gcmVnZXhTYWZlKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXCQvZywgJyQkJCQnKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlRm9ybWF0ID0ga2V5ID0+IHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5LCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsd2F5c0Zvcm1hdCA/IHRoaXMuZm9ybWF0KHBhdGgsIHVuZGVmaW5lZCwgbG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IGtleVxuICAgICAgICB9KSA6IHBhdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0ga2V5LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgIGNvbnN0IGsgPSBwLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgY29uc3QgZiA9IHAuam9pbih0aGlzLmZvcm1hdFNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrLCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSksIGYsIGxuZywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgICBjb25zdCBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgPSBvcHRpb25zICYmIG9wdGlvbnMubWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyIHx8IHRoaXMub3B0aW9ucy5taXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXI7XG4gICAgY29uc3Qgc2tpcE9uVmFyaWFibGVzID0gb3B0aW9ucyAmJiBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyA6IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcztcbiAgICBjb25zdCB0b2RvcyA9IFt7XG4gICAgICByZWdleDogdGhpcy5yZWdleHBVbmVzY2FwZSxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHJlZ2V4U2FmZSh2YWwpXG4gICAgfSwge1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwLFxuICAgICAgc2FmZVZhbHVlOiB2YWwgPT4gdGhpcy5lc2NhcGVWYWx1ZSA/IHJlZ2V4U2FmZSh0aGlzLmVzY2FwZSh2YWwpKSA6IHJlZ2V4U2FmZSh2YWwpXG4gICAgfV07XG4gICAgdG9kb3MuZm9yRWFjaCh0b2RvID0+IHtcbiAgICAgIHJlcGxhY2VzID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHRvZG8ucmVnZXguZXhlYyhzdHIpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRWYXIgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHZhbHVlID0gaGFuZGxlRm9ybWF0KG1hdGNoZWRWYXIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyKHN0ciwgbWF0Y2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlb2YgdGVtcCA9PT0gJ3N0cmluZycgPyB0ZW1wIDogJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBtYXRjaGVkVmFyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcGFzcyBpbiB2YXJpYWJsZSAke21hdGNoZWRWYXJ9IGZvciBpbnRlcnBvbGF0aW5nICR7c3RyfWApO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlVmFsdWUgPSB0b2RvLnNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCBzYWZlVmFsdWUpO1xuICAgICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZXMrKztcbiAgICAgICAgaWYgKHJlcGxhY2VzID49IHRoaXMubWF4UmVwbGFjZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbmVzdChzdHIsIGZjKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGNsb25lZE9wdGlvbnM7XG4gICAgZnVuY3Rpb24gaGFuZGxlSGFzT3B0aW9ucyhrZXksIGluaGVyaXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNlcCA9IHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3I7XG4gICAgICBpZiAoa2V5LmluZGV4T2Yoc2VwKSA8IDApIHJldHVybiBrZXk7XG4gICAgICBjb25zdCBjID0ga2V5LnNwbGl0KG5ldyBSZWdFeHAoYCR7c2VwfVsgXSp7YCkpO1xuICAgICAgbGV0IG9wdGlvbnNTdHJpbmcgPSBgeyR7Y1sxXX1gO1xuICAgICAga2V5ID0gY1swXTtcbiAgICAgIG9wdGlvbnNTdHJpbmcgPSB0aGlzLmludGVycG9sYXRlKG9wdGlvbnNTdHJpbmcsIGNsb25lZE9wdGlvbnMpO1xuICAgICAgY29uc3QgbWF0Y2hlZFNpbmdsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goLycvZyk7XG4gICAgICBjb25zdCBtYXRjaGVkRG91YmxlUXVvdGVzID0gb3B0aW9uc1N0cmluZy5tYXRjaCgvXCIvZyk7XG4gICAgICBpZiAobWF0Y2hlZFNpbmdsZVF1b3RlcyAmJiBtYXRjaGVkU2luZ2xlUXVvdGVzLmxlbmd0aCAlIDIgPT09IDAgJiYgIW1hdGNoZWREb3VibGVRdW90ZXMgfHwgbWF0Y2hlZERvdWJsZVF1b3Rlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIG9wdGlvbnNTdHJpbmcgPSBvcHRpb25zU3RyaW5nLnJlcGxhY2UoLycvZywgJ1wiJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjbG9uZWRPcHRpb25zID0gSlNPTi5wYXJzZShvcHRpb25zU3RyaW5nKTtcbiAgICAgICAgaWYgKGluaGVyaXRlZE9wdGlvbnMpIGNsb25lZE9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uaW5oZXJpdGVkT3B0aW9ucyxcbiAgICAgICAgICAuLi5jbG9uZWRPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYGZhaWxlZCBwYXJzaW5nIG9wdGlvbnMgc3RyaW5nIGluIG5lc3RpbmcgZm9yIGtleSAke2tleX1gLCBlKTtcbiAgICAgICAgcmV0dXJuIGAke2tleX0ke3NlcH0ke29wdGlvbnNTdHJpbmd9YDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2YgY2xvbmVkT3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJyA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgbGV0IGRvUmVkdWNlID0gZmFsc2U7XG4gICAgICBpZiAobWF0Y2hbMF0uaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgIT09IC0xICYmICEvey4qfS8udGVzdChtYXRjaFsxXSkpIHtcbiAgICAgICAgY29uc3QgciA9IG1hdGNoWzFdLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSk7XG4gICAgICAgIG1hdGNoWzFdID0gci5zaGlmdCgpO1xuICAgICAgICBmb3JtYXR0ZXJzID0gcjtcbiAgICAgICAgZG9SZWR1Y2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBmYyhoYW5kbGVIYXNPcHRpb25zLmNhbGwodGhpcywgbWF0Y2hbMV0udHJpbSgpLCBjbG9uZWRPcHRpb25zKSwgY2xvbmVkT3B0aW9ucyk7XG4gICAgICBpZiAodmFsdWUgJiYgbWF0Y2hbMF0gPT09IHN0ciAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgbWlzc2VkIHRvIHJlc29sdmUgJHttYXRjaFsxXX0gZm9yIG5lc3RpbmcgJHtzdHJ9YCk7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZWR1Y2UpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXJzLnJlZHVjZSgodiwgZikgPT4gdGhpcy5mb3JtYXQodiwgZiwgb3B0aW9ucy5sbmcsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IG1hdGNoWzFdLnRyaW0oKVxuICAgICAgICB9KSwgdmFsdWUudHJpbSgpKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCB2YWx1ZSk7XG4gICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRm9ybWF0U3RyKGZvcm1hdFN0cikge1xuICBsZXQgZm9ybWF0TmFtZSA9IGZvcm1hdFN0ci50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgY29uc3QgZm9ybWF0T3B0aW9ucyA9IHt9O1xuICBpZiAoZm9ybWF0U3RyLmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgY29uc3QgcCA9IGZvcm1hdFN0ci5zcGxpdCgnKCcpO1xuICAgIGZvcm1hdE5hbWUgPSBwWzBdLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGNvbnN0IG9wdFN0ciA9IHBbMV0uc3Vic3RyaW5nKDAsIHBbMV0ubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGZvcm1hdE5hbWUgPT09ICdjdXJyZW5jeScgJiYgb3B0U3RyLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgIGlmICghZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSkgZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSA9IG9wdFN0ci50cmltKCk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXROYW1lID09PSAncmVsYXRpdmV0aW1lJyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLnJhbmdlKSBmb3JtYXRPcHRpb25zLnJhbmdlID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IG9wdFN0ci5zcGxpdCgnOycpO1xuICAgICAgb3B0cy5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgIGlmICghb3B0KSByZXR1cm47XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gb3B0LnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IHJlc3Quam9pbignOicpLnRyaW0oKS5yZXBsYWNlKC9eJyt8JyskL2csICcnKTtcbiAgICAgICAgaWYgKCFmb3JtYXRPcHRpb25zW2tleS50cmltKCldKSBmb3JtYXRPcHRpb25zW2tleS50cmltKCldID0gdmFsO1xuICAgICAgICBpZiAodmFsID09PSAnZmFsc2UnKSBmb3JtYXRPcHRpb25zW2tleS50cmltKCldID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWwgPT09ICd0cnVlJykgZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSA9IHRydWU7XG4gICAgICAgIGlmICghaXNOYU4odmFsKSkgZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0TmFtZSxcbiAgICBmb3JtYXRPcHRpb25zXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZUZvcm1hdHRlcih2YWwsIGxuZywgb3B0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IGxuZyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjYWNoZVtrZXldO1xuICAgIGlmICghZm9ybWF0dGVyKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBmbihnZXRDbGVhbmVkQ29kZShsbmcpLCBvcHRpb25zKTtcbiAgICAgIGNhY2hlW2tleV0gPSBmb3JtYXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZXIodmFsKTtcbiAgfTtcbn1cbmNsYXNzIEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdmb3JtYXR0ZXInKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG51bWJlcjogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pLFxuICAgICAgY3VycmVuY3k6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIGRhdGV0aW1lOiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIHJlbGF0aXZldGltZTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsLCBvcHQucmFuZ2UgfHwgJ2RheScpO1xuICAgICAgfSksXG4gICAgICBsaXN0OiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH1cbiAgaW5pdChzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICAgIH07XG4gICAgY29uc3QgaU9wdHMgPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5mb3JtYXRTZXBhcmF0b3IgPSBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgPyBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgOiBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICB9XG4gIGFkZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGZjO1xuICB9XG4gIGFkZENhY2hlZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcihmYyk7XG4gIH1cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQsIGxuZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtcyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtc1tvcHRpb25zLmludGVycG9sYXRpb25rZXldIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGwgPSB2YWxPcHRpb25zLmxvY2FsZSB8fCB2YWxPcHRpb25zLmxuZyB8fCBvcHRpb25zLmxvY2FsZSB8fCBvcHRpb25zLmxuZyB8fCBsbmc7XG4gICAgICAgICAgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKG1lbSwgbCwge1xuICAgICAgICAgICAgLi4uZm9ybWF0T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi52YWxPcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHRoZXJlIHdhcyBubyBmb3JtYXQgZnVuY3Rpb24gZm9yICR7Zm9ybWF0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW07XG4gICAgfSwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUGVuZGluZyhxLCBuYW1lKSB7XG4gIGlmIChxLnBlbmRpbmdbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBxLnBlbmRpbmdbbmFtZV07XG4gICAgcS5wZW5kaW5nQ291bnQtLTtcbiAgfVxufVxuY2xhc3MgQ29ubmVjdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoYmFja2VuZCwgc3RvcmUsIHNlcnZpY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IHNlcnZpY2VzLmxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdiYWNrZW5kQ29ubmVjdG9yJyk7XG4gICAgdGhpcy53YWl0aW5nUmVhZHMgPSBbXTtcbiAgICB0aGlzLm1heFBhcmFsbGVsUmVhZHMgPSBvcHRpb25zLm1heFBhcmFsbGVsUmVhZHMgfHwgMTA7XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMgPSAwO1xuICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA+PSAwID8gb3B0aW9ucy5tYXhSZXRyaWVzIDogNTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG9wdGlvbnMucmV0cnlUaW1lb3V0ID49IDEgPyBvcHRpb25zLnJldHJ5VGltZW91dCA6IDM1MDtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIGlmICh0aGlzLmJhY2tlbmQgJiYgdGhpcy5iYWNrZW5kLmluaXQpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5pbml0KHNlcnZpY2VzLCBvcHRpb25zLmJhY2tlbmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBxdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRvTG9hZCA9IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSB7fTtcbiAgICBjb25zdCB0b0xvYWRMYW5ndWFnZXMgPSB7fTtcbiAgICBjb25zdCB0b0xvYWROYW1lc3BhY2VzID0ge307XG4gICAgbGFuZ3VhZ2VzLmZvckVhY2gobG5nID0+IHtcbiAgICAgIGxldCBoYXNBbGxOYW1lc3BhY2VzID0gdHJ1ZTtcbiAgICAgIG5hbWVzcGFjZXMuZm9yRWFjaChucyA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtsbmd9fCR7bnN9YDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlbG9hZCAmJiB0aGlzLnN0b3JlLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZVtuYW1lXSA8IDApIDsgZWxzZSBpZiAodGhpcy5zdGF0ZVtuYW1lXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChwZW5kaW5nW25hbWVdID09PSB1bmRlZmluZWQpIHBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAxO1xuICAgICAgICAgIGhhc0FsbE5hbWVzcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodG9Mb2FkW25hbWVdID09PSB1bmRlZmluZWQpIHRvTG9hZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZE5hbWVzcGFjZXNbbnNdID09PSB1bmRlZmluZWQpIHRvTG9hZE5hbWVzcGFjZXNbbnNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWhhc0FsbE5hbWVzcGFjZXMpIHRvTG9hZExhbmd1YWdlc1tsbmddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmtleXModG9Mb2FkKS5sZW5ndGggfHwgT2JqZWN0LmtleXMocGVuZGluZykubGVuZ3RoKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICBwZW5kaW5nLFxuICAgICAgICBwZW5kaW5nQ291bnQ6IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCxcbiAgICAgICAgbG9hZGVkOiB7fSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdG9Mb2FkOiBPYmplY3Qua2V5cyh0b0xvYWQpLFxuICAgICAgcGVuZGluZzogT2JqZWN0LmtleXMocGVuZGluZyksXG4gICAgICB0b0xvYWRMYW5ndWFnZXM6IE9iamVjdC5rZXlzKHRvTG9hZExhbmd1YWdlcyksXG4gICAgICB0b0xvYWROYW1lc3BhY2VzOiBPYmplY3Qua2V5cyh0b0xvYWROYW1lc3BhY2VzKVxuICAgIH07XG4gIH1cbiAgbG9hZGVkKG5hbWUsIGVyciwgZGF0YSkge1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgaWYgKGVycikgdGhpcy5lbWl0KCdmYWlsZWRMb2FkaW5nJywgbG5nLCBucywgZXJyKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCBkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZVtuYW1lXSA9IGVyciA/IC0xIDogMjtcbiAgICBjb25zdCBsb2FkZWQgPSB7fTtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2gocSA9PiB7XG4gICAgICBwdXNoUGF0aChxLmxvYWRlZCwgW2xuZ10sIG5zKTtcbiAgICAgIHJlbW92ZVBlbmRpbmcocSwgbmFtZSk7XG4gICAgICBpZiAoZXJyKSBxLmVycm9ycy5wdXNoKGVycik7XG4gICAgICBpZiAocS5wZW5kaW5nQ291bnQgPT09IDAgJiYgIXEuZG9uZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhxLmxvYWRlZCkuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZFtsXSkgbG9hZGVkW2xdID0ge307XG4gICAgICAgICAgY29uc3QgbG9hZGVkS2V5cyA9IHEubG9hZGVkW2xdO1xuICAgICAgICAgIGlmIChsb2FkZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9hZGVkS2V5cy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICBpZiAobG9hZGVkW2xdW25dID09PSB1bmRlZmluZWQpIGxvYWRlZFtsXVtuXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxLmRvbmUgPSB0cnVlO1xuICAgICAgICBpZiAocS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcS5jYWxsYmFjayhxLmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcS5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdsb2FkZWQnLCBsb2FkZWQpO1xuICAgIHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcihxID0+ICFxLmRvbmUpO1xuICB9XG4gIHJlYWQobG5nLCBucywgZmNOYW1lKSB7XG4gICAgbGV0IHRyaWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGxldCB3YWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0aGlzLnJldHJ5VGltZW91dDtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWxuZy5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7XG4gICAgaWYgKHRoaXMucmVhZGluZ0NhbGxzID49IHRoaXMubWF4UGFyYWxsZWxSZWFkcykge1xuICAgICAgdGhpcy53YWl0aW5nUmVhZHMucHVzaCh7XG4gICAgICAgIGxuZyxcbiAgICAgICAgbnMsXG4gICAgICAgIGZjTmFtZSxcbiAgICAgICAgdHJpZWQsXG4gICAgICAgIHdhaXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMrKztcbiAgICBjb25zdCByZXNvbHZlciA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgIHRoaXMucmVhZGluZ0NhbGxzLS07XG4gICAgICBpZiAodGhpcy53YWl0aW5nUmVhZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy53YWl0aW5nUmVhZHMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5yZWFkKG5leHQubG5nLCBuZXh0Lm5zLCBuZXh0LmZjTmFtZSwgbmV4dC50cmllZCwgbmV4dC53YWl0LCBuZXh0LmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgJiYgZGF0YSAmJiB0cmllZCA8IHRoaXMubWF4UmV0cmllcykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlYWQuY2FsbCh0aGlzLCBsbmcsIG5zLCBmY05hbWUsIHRyaWVkICsgMSwgd2FpdCAqIDIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBmYyA9IHRoaXMuYmFja2VuZFtmY05hbWVdLmJpbmQodGhpcy5iYWNrZW5kKTtcbiAgICBpZiAoZmMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gZmMobG5nLCBucyk7XG4gICAgICAgIGlmIChyICYmIHR5cGVvZiByLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByLnRoZW4oZGF0YSA9PiByZXNvbHZlcihudWxsLCBkYXRhKSkuY2F0Y2gocmVzb2x2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVyKG51bGwsIHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZXIoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZjKGxuZywgbnMsIHJlc29sdmVyKTtcbiAgfVxuICBwcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZXMgPT09ICdzdHJpbmcnKSBsYW5ndWFnZXMgPSB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxhbmd1YWdlcyk7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJykgbmFtZXNwYWNlcyA9IFtuYW1lc3BhY2VzXTtcbiAgICBjb25zdCB0b0xvYWQgPSB0aGlzLnF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBpZiAoIXRvTG9hZC50b0xvYWQubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRvTG9hZC5wZW5kaW5nLmxlbmd0aCkgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0xvYWQudG9Mb2FkLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLmxvYWRPbmUobmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHt9LCBjYWxsYmFjayk7XG4gIH1cbiAgcmVsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcywge1xuICAgICAgcmVsb2FkOiB0cnVlXG4gICAgfSwgY2FsbGJhY2spO1xuICB9XG4gIGxvYWRPbmUobmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgdGhpcy5yZWFkKGxuZywgbnMsICdyZWFkJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHRoaXMubG9nZ2VyLndhcm4oYCR7cHJlZml4fWxvYWRpbmcgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ30gZmFpbGVkYCwgZXJyKTtcbiAgICAgIGlmICghZXJyICYmIGRhdGEpIHRoaXMubG9nZ2VyLmxvZyhgJHtwcmVmaXh9bG9hZGVkIG5hbWVzcGFjZSAke25zfSBmb3IgbGFuZ3VhZ2UgJHtsbmd9YCwgZGF0YSk7XG4gICAgICB0aGlzLmxvYWRlZChuYW1lLCBlcnIsIGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIHNhdmVNaXNzaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIGlzVXBkYXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIGxldCBjbGIgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6ICgpID0+IHt9O1xuICAgIGlmICh0aGlzLnNlcnZpY2VzLnV0aWxzICYmIHRoaXMuc2VydmljZXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnNlcnZpY2VzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBkaWQgbm90IHNhdmUga2V5IFwiJHtrZXl9XCIgYXMgdGhlIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCBrZXkgPT09ICcnKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYmFja2VuZCAmJiB0aGlzLmJhY2tlbmQuY3JlYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc1VwZGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kLmNyZWF0ZS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgICBpZiAoZmMubGVuZ3RoIDwgNikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByO1xuICAgICAgICAgIGlmIChmYy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByLnRoZW4oZGF0YSA9PiBjbGIobnVsbCwgZGF0YSkpLmNhdGNoKGNsYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYihudWxsLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsYihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBjbGIsIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIHJldHVybiB7XG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGluaXRJbW1lZGlhdGU6IHRydWUsXG4gICAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgICBkZWZhdWx0TlM6IFsndHJhbnNsYXRpb24nXSxcbiAgICBmYWxsYmFja0xuZzogWydkZXYnXSxcbiAgICBmYWxsYmFja05TOiBmYWxzZSxcbiAgICBzdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgICBub25FeHBsaWNpdFN1cHBvcnRlZExuZ3M6IGZhbHNlLFxuICAgIGxvYWQ6ICdhbGwnLFxuICAgIHByZWxvYWQ6IGZhbHNlLFxuICAgIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0cnVlLFxuICAgIGtleVNlcGFyYXRvcjogJy4nLFxuICAgIG5zU2VwYXJhdG9yOiAnOicsXG4gICAgcGx1cmFsU2VwYXJhdG9yOiAnXycsXG4gICAgY29udGV4dFNlcGFyYXRvcjogJ18nLFxuICAgIHBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzOiBmYWxzZSxcbiAgICBzYXZlTWlzc2luZzogZmFsc2UsXG4gICAgdXBkYXRlTWlzc2luZzogZmFsc2UsXG4gICAgc2F2ZU1pc3NpbmdUbzogJ2ZhbGxiYWNrJyxcbiAgICBzYXZlTWlzc2luZ1BsdXJhbHM6IHRydWUsXG4gICAgbWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICAgIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjogZmFsc2UsXG4gICAgcG9zdFByb2Nlc3M6IGZhbHNlLFxuICAgIHBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkOiBmYWxzZSxcbiAgICByZXR1cm5OdWxsOiBmYWxzZSxcbiAgICByZXR1cm5FbXB0eVN0cmluZzogdHJ1ZSxcbiAgICByZXR1cm5PYmplY3RzOiBmYWxzZSxcbiAgICBqb2luQXJyYXlzOiBmYWxzZSxcbiAgICByZXR1cm5lZE9iamVjdEhhbmRsZXI6IGZhbHNlLFxuICAgIHBhcnNlTWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICAgIGFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleTogZmFsc2UsXG4gICAgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGU6IGZhbHNlLFxuICAgIG92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGUoYXJncykge1xuICAgICAgbGV0IHJldCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JykgcmV0ID0gYXJnc1sxXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycpIHJldC5kZWZhdWx0VmFsdWUgPSBhcmdzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnc3RyaW5nJykgcmV0LnREZXNjcmlwdGlvbiA9IGFyZ3NbMl07XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBhcmdzWzNdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1szXSB8fCBhcmdzWzJdO1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgcmV0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGludGVycG9sYXRpb246IHtcbiAgICAgIGVzY2FwZVZhbHVlOiB0cnVlLFxuICAgICAgZm9ybWF0OiB2YWx1ZSA9PiB2YWx1ZSxcbiAgICAgIHByZWZpeDogJ3t7JyxcbiAgICAgIHN1ZmZpeDogJ319JyxcbiAgICAgIGZvcm1hdFNlcGFyYXRvcjogJywnLFxuICAgICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcbiAgICAgIG5lc3RpbmdQcmVmaXg6ICckdCgnLFxuICAgICAgbmVzdGluZ1N1ZmZpeDogJyknLFxuICAgICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3I6ICcsJyxcbiAgICAgIG1heFJlcGxhY2VzOiAxMDAwLFxuICAgICAgc2tpcE9uVmFyaWFibGVzOiB0cnVlXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMubnMgPSBbb3B0aW9ucy5uc107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja0xuZyA9PT0gJ3N0cmluZycpIG9wdGlvbnMuZmFsbGJhY2tMbmcgPSBbb3B0aW9ucy5mYWxsYmFja0xuZ107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja05TID09PSAnc3RyaW5nJykgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG4gIGlmIChvcHRpb25zLnN1cHBvcnRlZExuZ3MgJiYgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmluZGV4T2YoJ2NpbW9kZScpIDwgMCkge1xuICAgIG9wdGlvbnMuc3VwcG9ydGVkTG5ncyA9IG9wdGlvbnMuc3VwcG9ydGVkTG5ncy5jb25jYXQoWydjaW1vZGUnXSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gYmluZE1lbWJlckZ1bmN0aW9ucyhpbnN0KSB7XG4gIGNvbnN0IG1lbXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdCkpO1xuICBtZW1zLmZvckVhY2gobWVtID0+IHtcbiAgICBpZiAodHlwZW9mIGluc3RbbWVtXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdFttZW1dID0gaW5zdFttZW1dLmJpbmQoaW5zdCk7XG4gICAgfVxuICB9KTtcbn1cbmNsYXNzIEkxOG4gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2VydmljZXMgPSB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgdGhpcy5tb2R1bGVzID0ge1xuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICBiaW5kTWVtYmVyRnVuY3Rpb25zKHRoaXMpO1xuICAgIGlmIChjYWxsYmFjayAmJiAhdGhpcy5pc0luaXRpYWxpemVkICYmICFvcHRpb25zLmlzQ2xvbmUpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmluaXRJbW1lZGlhdGUpIHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBpbml0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZGVmYXVsdE5TICYmIG9wdGlvbnMuZGVmYXVsdE5TICE9PSBmYWxzZSAmJiBvcHRpb25zLm5zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ucy5pbmRleE9mKCd0cmFuc2xhdGlvbicpIDwgMCkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZk9wdHMgPSBnZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZPcHRzLFxuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4udHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgLi4uZGVmT3B0cy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uc1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzT25EZW1hbmQoQ2xhc3NPck9iamVjdCkge1xuICAgICAgaWYgKCFDbGFzc09yT2JqZWN0KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgQ2xhc3NPck9iamVjdCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBDbGFzc09yT2JqZWN0KCk7XG4gICAgICByZXR1cm4gQ2xhc3NPck9iamVjdDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkge1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sb2dnZXIpIHtcbiAgICAgICAgYmFzZUxvZ2dlci5pbml0KGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxvZ2dlciksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQobnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXR0ZXI7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLm1vZHVsZXMuZm9ybWF0dGVyO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gRm9ybWF0dGVyO1xuICAgICAgfVxuICAgICAgY29uc3QgbHUgPSBuZXcgTGFuZ3VhZ2VVdGlsKHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUodGhpcy5vcHRpb25zLnJlc291cmNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNlcnZpY2VzO1xuICAgICAgcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgICAgcy5yZXNvdXJjZVN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHMubGFuZ3VhZ2VVdGlscyA9IGx1O1xuICAgICAgcy5wbHVyYWxSZXNvbHZlciA9IG5ldyBQbHVyYWxSZXNvbHZlcihsdSwge1xuICAgICAgICBwcmVwZW5kOiB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yLFxuICAgICAgICBjb21wYXRpYmlsaXR5SlNPTjogdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OLFxuICAgICAgICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4XG4gICAgICB9KTtcbiAgICAgIGlmIChmb3JtYXR0ZXIgJiYgKCF0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgfHwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID09PSBkZWZPcHRzLmludGVycG9sYXRpb24uZm9ybWF0KSkge1xuICAgICAgICBzLmZvcm1hdHRlciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQoZm9ybWF0dGVyKTtcbiAgICAgICAgcy5mb3JtYXR0ZXIuaW5pdChzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPSBzLmZvcm1hdHRlci5mb3JtYXQuYmluZChzLmZvcm1hdHRlcik7XG4gICAgICB9XG4gICAgICBzLmludGVycG9sYXRvciA9IG5ldyBJbnRlcnBvbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIHMudXRpbHMgPSB7XG4gICAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogdGhpcy5oYXNMb2FkZWROYW1lc3BhY2UuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3IoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3Rvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcikge1xuICAgICAgICBzLmxhbmd1YWdlRGV0ZWN0b3IgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKTtcbiAgICAgICAgaWYgKHMubGFuZ3VhZ2VEZXRlY3Rvci5pbml0KSBzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdChzLCB0aGlzLm9wdGlvbnMuZGV0ZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KSB7XG4gICAgICAgIHMuaTE4bkZvcm1hdCA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQpO1xuICAgICAgICBpZiAocy5pMThuRm9ybWF0LmluaXQpIHMuaTE4bkZvcm1hdC5pbml0KHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IodGhpcy5zZXJ2aWNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNsYXRvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICBpZiAobS5pbml0KSBtLmluaXQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgY29uc3QgY29kZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgaWYgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbMF0gIT09ICdkZXYnKSB0aGlzLm9wdGlvbnMubG5nID0gY29kZXNbMF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBubyBsYW5ndWFnZURldGVjdG9yIGlzIHVzZWQgYW5kIG5vIGxuZyBpcyBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlQXBpID0gWydnZXRSZXNvdXJjZScsICdoYXNSZXNvdXJjZUJ1bmRsZScsICdnZXRSZXNvdXJjZUJ1bmRsZScsICdnZXREYXRhQnlMYW5ndWFnZSddO1xuICAgIHN0b3JlQXBpLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmVBcGlDaGFpbmVkID0gWydhZGRSZXNvdXJjZScsICdhZGRSZXNvdXJjZXMnLCAnYWRkUmVzb3VyY2VCdW5kbGUnLCAncmVtb3ZlUmVzb3VyY2VCdW5kbGUnXTtcbiAgICBzdG9yZUFwaUNoYWluZWQuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaW5pc2ggPSAoZXJyLCB0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgIXRoaXMuaW5pdGlhbGl6ZWRTdG9yZU9uY2UpIHRoaXMubG9nZ2VyLndhcm4oJ2luaXQ6IGkxOG5leHQgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gWW91IHNob3VsZCBjYWxsIGluaXQganVzdCBvbmNlIScpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB0aGlzLmxvZ2dlci5sb2coJ2luaXRpYWxpemVkJywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0KCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgdCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnICYmICF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBmaW5pc2gobnVsbCwgdGhpcy50LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jaGFuZ2VMYW5ndWFnZSh0aGlzLm9wdGlvbnMubG5nLCBmaW5pc2gpO1xuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgIXRoaXMub3B0aW9ucy5pbml0SW1tZWRpYXRlKSB7XG4gICAgICBsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQobG9hZCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkUmVzb3VyY2VzKGxhbmd1YWdlKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICAgIGxldCB1c2VkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjb25zdCB1c2VkTG5nID0gdHlwZW9mIGxhbmd1YWdlID09PSAnc3RyaW5nJyA/IGxhbmd1YWdlIDogdGhpcy5sYW5ndWFnZTtcbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnZnVuY3Rpb24nKSB1c2VkQ2FsbGJhY2sgPSBsYW5ndWFnZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgdGhpcy5vcHRpb25zLnBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzKSB7XG4gICAgICBpZiAodXNlZExuZyAmJiB1c2VkTG5nLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnICYmICghdGhpcy5vcHRpb25zLnByZWxvYWQgfHwgdGhpcy5vcHRpb25zLnByZWxvYWQubGVuZ3RoID09PSAwKSkgcmV0dXJuIHVzZWRDYWxsYmFjaygpO1xuICAgICAgY29uc3QgdG9Mb2FkID0gW107XG4gICAgICBjb25zdCBhcHBlbmQgPSBsbmcgPT4ge1xuICAgICAgICBpZiAoIWxuZykgcmV0dXJuO1xuICAgICAgICBpZiAobG5nID09PSAnY2ltb2RlJykgcmV0dXJuO1xuICAgICAgICBjb25zdCBsbmdzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsbmcpO1xuICAgICAgICBsbmdzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKGwgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgICAgaWYgKHRvTG9hZC5pbmRleE9mKGwpIDwgMCkgdG9Mb2FkLnB1c2gobCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICghdXNlZExuZykge1xuICAgICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgICBmYWxsYmFja3MuZm9yRWFjaChsID0+IGFwcGVuZChsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQodXNlZExuZyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByZWxvYWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnByZWxvYWQuZm9yRWFjaChsID0+IGFwcGVuZChsKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IubG9hZCh0b0xvYWQsIHRoaXMub3B0aW9ucy5ucywgZSA9PiB7XG4gICAgICAgIGlmICghZSAmJiAhdGhpcy5yZXNvbHZlZExhbmd1YWdlICYmIHRoaXMubGFuZ3VhZ2UpIHRoaXMuc2V0UmVzb2x2ZWRMYW5ndWFnZSh0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgdXNlZENhbGxiYWNrKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZWRDYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVsb2FkUmVzb3VyY2VzKGxuZ3MsIG5zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoIWxuZ3MpIGxuZ3MgPSB0aGlzLmxhbmd1YWdlcztcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5ucztcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnJlbG9hZChsbmdzLCBucywgZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIHVzZShtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYW4gdW5kZWZpbmVkIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAoIW1vZHVsZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhIHdyb25nIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdiYWNrZW5kJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmJhY2tlbmQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xvZ2dlcicgfHwgbW9kdWxlLmxvZyAmJiBtb2R1bGUud2FybiAmJiBtb2R1bGUuZXJyb3IpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sb2dnZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xhbmd1YWdlRGV0ZWN0b3InKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3RvciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnaTE4bkZvcm1hdCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5pMThuRm9ybWF0ID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdwb3N0UHJvY2Vzc29yJykge1xuICAgICAgcG9zdFByb2Nlc3Nvci5hZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSk7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2Zvcm1hdHRlcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJzNyZFBhcnR5Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLnB1c2gobW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UmVzb2x2ZWRMYW5ndWFnZShsKSB7XG4gICAgaWYgKCFsIHx8ICF0aGlzLmxhbmd1YWdlcykgcmV0dXJuO1xuICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGwpID4gLTEpIHJldHVybjtcbiAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgdGhpcy5sYW5ndWFnZXMubGVuZ3RoOyBsaSsrKSB7XG4gICAgICBjb25zdCBsbmdJbkxuZ3MgPSB0aGlzLmxhbmd1YWdlc1tsaV07XG4gICAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsbmdJbkxuZ3MpID4gLTEpIGNvbnRpbnVlO1xuICAgICAgaWYgKHRoaXMuc3RvcmUuaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zKGxuZ0luTG5ncykpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbG5nSW5MbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSBsbmc7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2luZycsIGxuZyk7XG4gICAgY29uc3Qgc2V0TG5nUHJvcHMgPSBsID0+IHtcbiAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsO1xuICAgICAgdGhpcy5sYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGwpO1xuICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKGwpO1xuICAgIH07XG4gICAgY29uc3QgZG9uZSA9IChlcnIsIGwpID0+IHtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudCguLi5hcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnQoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0TG5nID0gbG5ncyA9PiB7XG4gICAgICBpZiAoIWxuZyAmJiAhbG5ncyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IpIGxuZ3MgPSBbXTtcbiAgICAgIGNvbnN0IGwgPSB0eXBlb2YgbG5ncyA9PT0gJ3N0cmluZycgPyBsbmdzIDogdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEJlc3RNYXRjaEZyb21Db2RlcyhsbmdzKTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdG9yLmxhbmd1YWdlKSB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmNhY2hlVXNlckxhbmd1YWdlKSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuY2FjaGVVc2VyTGFuZ3VhZ2UobCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRSZXNvdXJjZXMobCwgZXJyID0+IHtcbiAgICAgICAgZG9uZShlcnIsIGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgc2V0TG5nKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKSk7XG4gICAgfSBlbHNlIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkudGhlbihzZXRMbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdChzZXRMbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMbmcobG5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGdldEZpeGVkVChsbmcsIG5zLCBrZXlQcmVmaXgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjb25zdCBmaXhlZFQgPSBmdW5jdGlvbiAoa2V5LCBvcHRzKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMiA/IF9sZW4zIC0gMiA6IDApLCBfa2V5MyA9IDI7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gMl0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBfdGhpczMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihba2V5LCBvcHRzXS5jb25jYXQocmVzdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxuZyA9IG9wdGlvbnMubG5nIHx8IGZpeGVkVC5sbmc7XG4gICAgICBvcHRpb25zLmxuZ3MgPSBvcHRpb25zLmxuZ3MgfHwgZml4ZWRULmxuZ3M7XG4gICAgICBvcHRpb25zLm5zID0gb3B0aW9ucy5ucyB8fCBmaXhlZFQubnM7XG4gICAgICBvcHRpb25zLmtleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4IHx8IGtleVByZWZpeCB8fCBmaXhlZFQua2V5UHJlZml4O1xuICAgICAgY29uc3Qga2V5U2VwYXJhdG9yID0gX3RoaXMzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcbiAgICAgIGxldCByZXN1bHRLZXk7XG4gICAgICBpZiAob3B0aW9ucy5rZXlQcmVmaXggJiYgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJlc3VsdEtleSA9IGtleS5tYXAoayA9PiBgJHtvcHRpb25zLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2t9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRLZXkgPSBvcHRpb25zLmtleVByZWZpeCA/IGAke29wdGlvbnMua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMzLnQocmVzdWx0S2V5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgbG5nID09PSAnc3RyaW5nJykge1xuICAgICAgZml4ZWRULmxuZyA9IGxuZztcbiAgICB9IGVsc2Uge1xuICAgICAgZml4ZWRULmxuZ3MgPSBsbmc7XG4gICAgfVxuICAgIGZpeGVkVC5ucyA9IG5zO1xuICAgIGZpeGVkVC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgcmV0dXJuIGZpeGVkVDtcbiAgfVxuICB0KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0b3IgJiYgdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZSguLi5hcmd1bWVudHMpO1xuICB9XG4gIGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICYmIHRoaXMudHJhbnNsYXRvci5leGlzdHMoLi4uYXJndW1lbnRzKTtcbiAgfVxuICBzZXREZWZhdWx0TmFtZXNwYWNlKG5zKSB7XG4gICAgdGhpcy5vcHRpb25zLmRlZmF1bHROUyA9IG5zO1xuICB9XG4gIGhhc0xvYWRlZE5hbWVzcGFjZShucykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuZXh0IHdhcyBub3QgaW5pdGlhbGl6ZWQnLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5sYW5ndWFnZXMgfHwgIXRoaXMubGFuZ3VhZ2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuLmxhbmd1YWdlcyB3ZXJlIHVuZGVmaW5lZCBvciBlbXB0eScsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG5nID0gb3B0aW9ucy5sbmcgfHwgdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8IHRoaXMubGFuZ3VhZ2VzWzBdO1xuICAgIGNvbnN0IGZhbGxiYWNrTG5nID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIDogZmFsc2U7XG4gICAgY29uc3QgbGFzdExuZyA9IHRoaXMubGFuZ3VhZ2VzW3RoaXMubGFuZ3VhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGxvYWROb3RQZW5kaW5nID0gKGwsIG4pID0+IHtcbiAgICAgIGNvbnN0IGxvYWRTdGF0ZSA9IHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5zdGF0ZVtgJHtsfXwke259YF07XG4gICAgICByZXR1cm4gbG9hZFN0YXRlID09PSAtMSB8fCBsb2FkU3RhdGUgPT09IDI7XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5wcmVjaGVjaykge1xuICAgICAgY29uc3QgcHJlUmVzdWx0ID0gb3B0aW9ucy5wcmVjaGVjayh0aGlzLCBsb2FkTm90UGVuZGluZyk7XG4gICAgICBpZiAocHJlUmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiBwcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5iYWNrZW5kIHx8IHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgJiYgIXRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxvYWROb3RQZW5kaW5nKGxuZywgbnMpICYmICghZmFsbGJhY2tMbmcgfHwgbG9hZE5vdFBlbmRpbmcobGFzdExuZywgbnMpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvYWROYW1lc3BhY2VzKG5zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ucykge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5zID09PSAnc3RyaW5nJykgbnMgPSBbbnNdO1xuICAgIG5zLmZvckVhY2gobiA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5zLmluZGV4T2YobikgPCAwKSB0aGlzLm9wdGlvbnMubnMucHVzaChuKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZExhbmd1YWdlcyhsbmdzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAodHlwZW9mIGxuZ3MgPT09ICdzdHJpbmcnKSBsbmdzID0gW2xuZ3NdO1xuICAgIGNvbnN0IHByZWxvYWRlZCA9IHRoaXMub3B0aW9ucy5wcmVsb2FkIHx8IFtdO1xuICAgIGNvbnN0IG5ld0xuZ3MgPSBsbmdzLmZpbHRlcihsbmcgPT4gcHJlbG9hZGVkLmluZGV4T2YobG5nKSA8IDApO1xuICAgIGlmICghbmV3TG5ncy5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnByZWxvYWQgPSBwcmVsb2FkZWQuY29uY2F0KG5ld0xuZ3MpO1xuICAgIHRoaXMubG9hZFJlc291cmNlcyhlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBkaXIobG5nKSB7XG4gICAgaWYgKCFsbmcpIGxuZyA9IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCAodGhpcy5sYW5ndWFnZXMgJiYgdGhpcy5sYW5ndWFnZXMubGVuZ3RoID4gMCA/IHRoaXMubGFuZ3VhZ2VzWzBdIDogdGhpcy5sYW5ndWFnZSk7XG4gICAgaWYgKCFsbmcpIHJldHVybiAncnRsJztcbiAgICBjb25zdCBydGxMbmdzID0gWydhcicsICdzaHUnLCAnc3FyJywgJ3NzaCcsICd4YWEnLCAneWhkJywgJ3l1ZCcsICdhYW8nLCAnYWJoJywgJ2FidicsICdhY20nLCAnYWNxJywgJ2FjdycsICdhY3gnLCAnYWN5JywgJ2FkZicsICdhZHMnLCAnYWViJywgJ2FlYycsICdhZmInLCAnYWpwJywgJ2FwYycsICdhcGQnLCAnYXJiJywgJ2FycScsICdhcnMnLCAnYXJ5JywgJ2FyeicsICdhdXonLCAnYXZsJywgJ2F5aCcsICdheWwnLCAnYXluJywgJ2F5cCcsICdiYnonLCAncGdhJywgJ2hlJywgJ2l3JywgJ3BzJywgJ3BidCcsICdwYnUnLCAncHN0JywgJ3BycCcsICdwcmQnLCAndWcnLCAndXInLCAneWRkJywgJ3lkcycsICd5aWgnLCAnamknLCAneWknLCAnaGJvJywgJ21lbicsICd4bW4nLCAnZmEnLCAnanByJywgJ3BlbycsICdwZXMnLCAncHJzJywgJ2R2JywgJ3NhbScsICdja2InXTtcbiAgICBjb25zdCBsYW5ndWFnZVV0aWxzID0gdGhpcy5zZXJ2aWNlcyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMgfHwgbmV3IExhbmd1YWdlVXRpbChnZXQoKSk7XG4gICAgcmV0dXJuIHJ0bExuZ3MuaW5kZXhPZihsYW5ndWFnZVV0aWxzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGxuZykpID4gLTEgfHwgbG5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignLWFyYWInKSA+IDEgPyAncnRsJyA6ICdsdHInO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBJMThuKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICBjbG9uZUluc3RhbmNlKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gICAgY29uc3QgZm9ya1Jlc291cmNlU3RvcmUgPSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkgZGVsZXRlIG9wdGlvbnMuZm9ya1Jlc291cmNlU3RvcmU7XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAuLi57XG4gICAgICAgIGlzQ2xvbmU6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb25lID0gbmV3IEkxOG4obWVyZ2VkT3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZGVidWcgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbG9uZS5sb2dnZXIgPSBjbG9uZS5sb2dnZXIuY2xvbmUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG1lbWJlcnNUb0NvcHkgPSBbJ3N0b3JlJywgJ3NlcnZpY2VzJywgJ2xhbmd1YWdlJ107XG4gICAgbWVtYmVyc1RvQ29weS5mb3JFYWNoKG0gPT4ge1xuICAgICAgY2xvbmVbbV0gPSB0aGlzW21dO1xuICAgIH0pO1xuICAgIGNsb25lLnNlcnZpY2VzID0ge1xuICAgICAgLi4udGhpcy5zZXJ2aWNlc1xuICAgIH07XG4gICAgY2xvbmUuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgaWYgKGZvcmtSZXNvdXJjZVN0b3JlKSB7XG4gICAgICBjbG9uZS5zdG9yZSA9IG5ldyBSZXNvdXJjZVN0b3JlKHRoaXMuc3RvcmUuZGF0YSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICBjbG9uZS5zZXJ2aWNlcy5yZXNvdXJjZVN0b3JlID0gY2xvbmUuc3RvcmU7XG4gICAgfVxuICAgIGNsb25lLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihjbG9uZS5zZXJ2aWNlcywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cbiAgICAgIGNsb25lLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0pO1xuICAgIGNsb25lLmluaXQobWVyZ2VkT3B0aW9ucywgY2FsbGJhY2spO1xuICAgIGNsb25lLnRyYW5zbGF0b3Iub3B0aW9ucyA9IG1lcmdlZE9wdGlvbnM7XG4gICAgY2xvbmUudHJhbnNsYXRvci5iYWNrZW5kQ29ubmVjdG9yLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICBsYW5ndWFnZXM6IHRoaXMubGFuZ3VhZ2VzLFxuICAgICAgcmVzb2x2ZWRMYW5ndWFnZTogdGhpcy5yZXNvbHZlZExhbmd1YWdlXG4gICAgfTtcbiAgfVxufVxuY29uc3QgaW5zdGFuY2UgPSBJMThuLmNyZWF0ZUluc3RhbmNlKCk7XG5pbnN0YW5jZS5jcmVhdGVJbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2U7XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlID0gaW5zdGFuY2UuY3JlYXRlSW5zdGFuY2U7XG5jb25zdCBkaXIgPSBpbnN0YW5jZS5kaXI7XG5jb25zdCBpbml0ID0gaW5zdGFuY2UuaW5pdDtcbmNvbnN0IGxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5sb2FkUmVzb3VyY2VzO1xuY29uc3QgcmVsb2FkUmVzb3VyY2VzID0gaW5zdGFuY2UucmVsb2FkUmVzb3VyY2VzO1xuY29uc3QgdXNlID0gaW5zdGFuY2UudXNlO1xuY29uc3QgY2hhbmdlTGFuZ3VhZ2UgPSBpbnN0YW5jZS5jaGFuZ2VMYW5ndWFnZTtcbmNvbnN0IGdldEZpeGVkVCA9IGluc3RhbmNlLmdldEZpeGVkVDtcbmNvbnN0IHQgPSBpbnN0YW5jZS50O1xuY29uc3QgZXhpc3RzID0gaW5zdGFuY2UuZXhpc3RzO1xuY29uc3Qgc2V0RGVmYXVsdE5hbWVzcGFjZSA9IGluc3RhbmNlLnNldERlZmF1bHROYW1lc3BhY2U7XG5jb25zdCBoYXNMb2FkZWROYW1lc3BhY2UgPSBpbnN0YW5jZS5oYXNMb2FkZWROYW1lc3BhY2U7XG5jb25zdCBsb2FkTmFtZXNwYWNlcyA9IGluc3RhbmNlLmxvYWROYW1lc3BhY2VzO1xuY29uc3QgbG9hZExhbmd1YWdlcyA9IGluc3RhbmNlLmxvYWRMYW5ndWFnZXM7XG5cbmV4cG9ydCB7IGNoYW5nZUxhbmd1YWdlLCBjcmVhdGVJbnN0YW5jZSwgaW5zdGFuY2UgYXMgZGVmYXVsdCwgZGlyLCBleGlzdHMsIGdldEZpeGVkVCwgaGFzTG9hZGVkTmFtZXNwYWNlLCBpbml0LCBsb2FkTGFuZ3VhZ2VzLCBsb2FkTmFtZXNwYWNlcywgbG9hZFJlc291cmNlcywgcmVsb2FkUmVzb3VyY2VzLCBzZXREZWZhdWx0TmFtZXNwYWNlLCB0LCB1c2UgfTtcbiJdLCJuYW1lcyI6WyJjb25zb2xlTG9nZ2VyIiwidHlwZSIsImxvZyIsImFyZ3MiLCJvdXRwdXQiLCJ3YXJuIiwiZXJyb3IiLCJjb25zb2xlIiwiYXBwbHkiLCJMb2dnZXIiLCJjb25zdHJ1Y3RvciIsImNvbmNyZXRlTG9nZ2VyIiwib3B0aW9ucyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImluaXQiLCJwcmVmaXgiLCJsb2dnZXIiLCJkZWJ1ZyIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJmb3J3YXJkIiwiX2xlbjIiLCJfa2V5MiIsIl9sZW4zIiwiX2tleTMiLCJkZXByZWNhdGUiLCJfbGVuNCIsIl9rZXk0IiwibHZsIiwiZGVidWdPbmx5IiwiY3JlYXRlIiwibW9kdWxlTmFtZSIsImNsb25lIiwiYmFzZUxvZ2dlciIsIkV2ZW50RW1pdHRlciIsIm9ic2VydmVycyIsIm9uIiwiZXZlbnRzIiwibGlzdGVuZXIiLCJzcGxpdCIsImZvckVhY2giLCJldmVudCIsInB1c2giLCJvZmYiLCJmaWx0ZXIiLCJsIiwiZW1pdCIsImNsb25lZCIsImNvbmNhdCIsIm9ic2VydmVyIiwiZGVmZXIiLCJyZXMiLCJyZWoiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtYWtlU3RyaW5nIiwib2JqZWN0IiwiY29weSIsImEiLCJzIiwidCIsIm0iLCJnZXRMYXN0T2ZQYXRoIiwicGF0aCIsIkVtcHR5IiwiY2xlYW5LZXkiLCJrZXkiLCJpbmRleE9mIiwicmVwbGFjZSIsImNhbk5vdFRyYXZlcnNlRGVlcGVyIiwic3RhY2siLCJzaGlmdCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm9iaiIsImsiLCJzZXRQYXRoIiwibmV3VmFsdWUiLCJwdXNoUGF0aCIsImdldFBhdGgiLCJnZXRQYXRoV2l0aERlZmF1bHRzIiwiZGF0YSIsImRlZmF1bHREYXRhIiwidmFsdWUiLCJkZWVwRXh0ZW5kIiwidGFyZ2V0Iiwic291cmNlIiwib3ZlcndyaXRlIiwicHJvcCIsIlN0cmluZyIsInJlZ2V4RXNjYXBlIiwic3RyIiwiX2VudGl0eU1hcCIsImVzY2FwZSIsImNoYXJzIiwibG9va3NMaWtlT2JqZWN0UGF0aCIsIm5zU2VwYXJhdG9yIiwia2V5U2VwYXJhdG9yIiwicG9zc2libGVDaGFycyIsImMiLCJyIiwiUmVnRXhwIiwibWFwIiwiam9pbiIsIm1hdGNoZWQiLCJ0ZXN0Iiwia2kiLCJzdWJzdHJpbmciLCJkZWVwRmluZCIsInBhdGhzIiwiY3VycmVudCIsImkiLCJqIiwicCIsInNsaWNlIiwibWl4IiwiZW5kc1dpdGgiLCJqb2luZWRQYXRoIiwiZ2V0Q2xlYW5lZENvZGUiLCJjb2RlIiwiUmVzb3VyY2VTdG9yZSIsIm5zIiwiZGVmYXVsdE5TIiwiaWdub3JlSlNPTlN0cnVjdHVyZSIsImFkZE5hbWVzcGFjZXMiLCJyZW1vdmVOYW1lc3BhY2VzIiwiaW5kZXgiLCJzcGxpY2UiLCJnZXRSZXNvdXJjZSIsImxuZyIsInJlc3VsdCIsImFkZFJlc291cmNlIiwic2lsZW50IiwiYWRkUmVzb3VyY2VzIiwicmVzb3VyY2VzIiwidG9TdHJpbmciLCJhZGRSZXNvdXJjZUJ1bmRsZSIsImRlZXAiLCJwYWNrIiwicmVtb3ZlUmVzb3VyY2VCdW5kbGUiLCJoYXNSZXNvdXJjZUJ1bmRsZSIsImdldFJlc291cmNlQnVuZGxlIiwiY29tcGF0aWJpbGl0eUFQSSIsImdldERhdGFCeUxhbmd1YWdlIiwiaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zIiwibiIsImtleXMiLCJmaW5kIiwidiIsInRvSlNPTiIsInBvc3RQcm9jZXNzb3IiLCJwcm9jZXNzb3JzIiwiYWRkUG9zdFByb2Nlc3NvciIsIm1vZHVsZSIsIm5hbWUiLCJoYW5kbGUiLCJ0cmFuc2xhdG9yIiwicHJvY2Vzc29yIiwicHJvY2VzcyIsImNoZWNrZWRMb2FkZWRGb3IiLCJUcmFuc2xhdG9yIiwic2VydmljZXMiLCJjaGFuZ2VMYW5ndWFnZSIsImxhbmd1YWdlIiwiZXhpc3RzIiwiaW50ZXJwb2xhdGlvbiIsInJlc29sdmVkIiwiZXh0cmFjdEZyb21LZXkiLCJuYW1lc3BhY2VzIiwid291bGRDaGVja0Zvck5zSW5LZXkiLCJzZWVtc05hdHVyYWxMYW5ndWFnZSIsInVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yIiwidXNlckRlZmluZWROc1NlcGFyYXRvciIsIm1hdGNoIiwiaW50ZXJwb2xhdG9yIiwibmVzdGluZ1JlZ2V4cCIsInBhcnRzIiwidHJhbnNsYXRlIiwibGFzdEtleSIsIm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyIiwiaXNBcnJheSIsInJldHVybkRldGFpbHMiLCJuYW1lc3BhY2UiLCJhcHBlbmROYW1lc3BhY2VUb0NJTW9kZSIsInRvTG93ZXJDYXNlIiwidXNlZEtleSIsImV4YWN0VXNlZEtleSIsInVzZWRMbmciLCJ1c2VkTlMiLCJ1c2VkUGFyYW1zIiwiZ2V0VXNlZFBhcmFtc0RldGFpbHMiLCJyZXNVc2VkS2V5IiwicmVzRXhhY3RVc2VkS2V5IiwicmVzVHlwZSIsIm5vT2JqZWN0Iiwiam9pbkFycmF5cyIsImhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0IiwiaTE4bkZvcm1hdCIsImhhbmRsZUFzT2JqZWN0IiwicmV0dXJuT2JqZWN0cyIsInJldHVybmVkT2JqZWN0SGFuZGxlciIsInJlc1R5cGVJc0FycmF5IiwibmV3S2V5VG9Vc2UiLCJkZWVwS2V5IiwiZXh0ZW5kVHJhbnNsYXRpb24iLCJ1c2VkRGVmYXVsdCIsIm5lZWRzUGx1cmFsSGFuZGxpbmciLCJjb3VudCIsImhhc0RlZmF1bHRWYWx1ZSIsImRlZmF1bHRWYWx1ZVN1ZmZpeCIsInBsdXJhbFJlc29sdmVyIiwiZ2V0U3VmZml4IiwiZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrIiwib3JkaW5hbCIsImRlZmF1bHRWYWx1ZSIsImlzVmFsaWRMb29rdXAiLCJtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkiLCJyZXNGb3JNaXNzaW5nIiwidXBkYXRlTWlzc2luZyIsImZrIiwibG5ncyIsImZhbGxiYWNrTG5ncyIsImxhbmd1YWdlVXRpbHMiLCJnZXRGYWxsYmFja0NvZGVzIiwiZmFsbGJhY2tMbmciLCJzYXZlTWlzc2luZ1RvIiwidG9SZXNvbHZlSGllcmFyY2h5Iiwic2VuZCIsInNwZWNpZmljRGVmYXVsdFZhbHVlIiwiZGVmYXVsdEZvck1pc3NpbmciLCJtaXNzaW5nS2V5SGFuZGxlciIsImJhY2tlbmRDb25uZWN0b3IiLCJzYXZlTWlzc2luZyIsInNhdmVNaXNzaW5nUGx1cmFscyIsImdldFN1ZmZpeGVzIiwic3VmZml4IiwiYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5IiwicGFyc2VNaXNzaW5nS2V5SGFuZGxlciIsIl90aGlzIiwicGFyc2UiLCJkZWZhdWx0VmFyaWFibGVzIiwic2tpcEludGVycG9sYXRpb24iLCJza2lwT25WYXJpYWJsZXMiLCJuZXN0QmVmIiwibmIiLCJpbnRlcnBvbGF0ZSIsIm5hIiwibmVzdEFmdCIsIm5lc3QiLCJjb250ZXh0IiwicmVzZXQiLCJwb3N0UHJvY2VzcyIsInBvc3RQcm9jZXNzb3JOYW1lcyIsImFwcGx5UG9zdFByb2Nlc3NvciIsInBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkIiwiaTE4blJlc29sdmVkIiwiZm91bmQiLCJleHRyYWN0ZWQiLCJmYWxsYmFja05TIiwibmVlZHNaZXJvU3VmZml4TG9va3VwIiwic2hvdWxkVXNlSW50bEFwaSIsIm5lZWRzQ29udGV4dEhhbmRsaW5nIiwiY29kZXMiLCJ1dGlscyIsImhhc0xvYWRlZE5hbWVzcGFjZSIsImZpbmFsS2V5cyIsImFkZExvb2t1cEtleXMiLCJwbHVyYWxTdWZmaXgiLCJ6ZXJvU3VmZml4IiwicGx1cmFsU2VwYXJhdG9yIiwib3JkaW5hbFByZWZpeCIsImNvbnRleHRLZXkiLCJjb250ZXh0U2VwYXJhdG9yIiwicG9zc2libGVLZXkiLCJwb3AiLCJyZXR1cm5OdWxsIiwicmV0dXJuRW1wdHlTdHJpbmciLCJyZXNvdXJjZVN0b3JlIiwib3B0aW9uc0tleXMiLCJ1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEiLCJvcHRpb24iLCJjYXBpdGFsaXplIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJMYW5ndWFnZVV0aWwiLCJzdXBwb3J0ZWRMbmdzIiwiZ2V0U2NyaXB0UGFydEZyb21Db2RlIiwiZm9ybWF0TGFuZ3VhZ2VDb2RlIiwiZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUiLCJzcGVjaWFsQ2FzZXMiLCJsb3dlckNhc2VMbmciLCJwYXJ0IiwiY2xlYW5Db2RlIiwiaXNTdXBwb3J0ZWRDb2RlIiwibG9hZCIsIm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncyIsImdldEJlc3RNYXRjaEZyb21Db2RlcyIsImNsZWFuZWRMbmciLCJsbmdPbmx5Iiwic3VwcG9ydGVkTG5nIiwiZmFsbGJhY2tzIiwiZGVmYXVsdCIsImZhbGxiYWNrQ29kZSIsImZhbGxiYWNrQ29kZXMiLCJhZGRDb2RlIiwiZmMiLCJzZXRzIiwibnIiLCJfcnVsZXNQbHVyYWxzVHlwZXMiLCJOdW1iZXIiLCJub25JbnRsVmVyc2lvbnMiLCJpbnRsVmVyc2lvbnMiLCJzdWZmaXhlc09yZGVyIiwiemVybyIsIm9uZSIsInR3byIsImZldyIsIm1hbnkiLCJvdGhlciIsImNyZWF0ZVJ1bGVzIiwicnVsZXMiLCJzZXQiLCJudW1iZXJzIiwicGx1cmFscyIsIlBsdXJhbFJlc29sdmVyIiwiY29tcGF0aWJpbGl0eUpTT04iLCJpbmNsdWRlcyIsIkludGwiLCJQbHVyYWxSdWxlcyIsImFkZFJ1bGUiLCJnZXRSdWxlIiwiZXJyIiwibmVlZHNQbHVyYWwiLCJydWxlIiwicmVzb2x2ZWRPcHRpb25zIiwicGx1cmFsQ2F0ZWdvcmllcyIsImdldFBsdXJhbEZvcm1zT2ZLZXkiLCJzb3J0IiwicGx1cmFsQ2F0ZWdvcnkxIiwicGx1cmFsQ2F0ZWdvcnkyIiwicGx1cmFsQ2F0ZWdvcnkiLCJwcmVwZW5kIiwibnVtYmVyIiwic2VsZWN0IiwiZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlIiwiaWR4Iiwibm9BYnMiLCJNYXRoIiwiYWJzIiwic2ltcGxpZnlQbHVyYWxTdWZmaXgiLCJyZXR1cm5TdWZmaXgiLCJkZWVwRmluZFdpdGhEZWZhdWx0cyIsIkludGVycG9sYXRvciIsImZvcm1hdCIsImVzY2FwZVZhbHVlIiwiaU9wdHMiLCJ1c2VSYXdWYWx1ZVRvRXNjYXBlIiwicHJlZml4RXNjYXBlZCIsInN1ZmZpeEVzY2FwZWQiLCJmb3JtYXRTZXBhcmF0b3IiLCJ1bmVzY2FwZVByZWZpeCIsInVuZXNjYXBlU3VmZml4IiwibmVzdGluZ1ByZWZpeCIsIm5lc3RpbmdQcmVmaXhFc2NhcGVkIiwibmVzdGluZ1N1ZmZpeCIsIm5lc3RpbmdTdWZmaXhFc2NhcGVkIiwibmVzdGluZ09wdGlvbnNTZXBhcmF0b3IiLCJtYXhSZXBsYWNlcyIsImFsd2F5c0Zvcm1hdCIsInJlc2V0UmVnRXhwIiwicmVnZXhwU3RyIiwicmVnZXhwIiwicmVnZXhwVW5lc2NhcGVTdHIiLCJyZWdleHBVbmVzY2FwZSIsIm5lc3RpbmdSZWdleHBTdHIiLCJyZXBsYWNlcyIsInJlZ2V4U2FmZSIsInZhbCIsImhhbmRsZUZvcm1hdCIsImludGVycG9sYXRpb25rZXkiLCJ0cmltIiwiZiIsIm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciIsInRvZG9zIiwicmVnZXgiLCJzYWZlVmFsdWUiLCJ0b2RvIiwiZXhlYyIsIm1hdGNoZWRWYXIiLCJ0ZW1wIiwibGFzdEluZGV4IiwiY2xvbmVkT3B0aW9ucyIsImhhbmRsZUhhc09wdGlvbnMiLCJpbmhlcml0ZWRPcHRpb25zIiwic2VwIiwib3B0aW9uc1N0cmluZyIsIm1hdGNoZWRTaW5nbGVRdW90ZXMiLCJtYXRjaGVkRG91YmxlUXVvdGVzIiwiSlNPTiIsImUiLCJmb3JtYXR0ZXJzIiwiZG9SZWR1Y2UiLCJlbGVtIiwicmVkdWNlIiwicGFyc2VGb3JtYXRTdHIiLCJmb3JtYXRTdHIiLCJmb3JtYXROYW1lIiwiZm9ybWF0T3B0aW9ucyIsIm9wdFN0ciIsImN1cnJlbmN5IiwicmFuZ2UiLCJvcHRzIiwib3B0IiwicmVzdCIsImlzTmFOIiwicGFyc2VJbnQiLCJjcmVhdGVDYWNoZWRGb3JtYXR0ZXIiLCJmbiIsImNhY2hlIiwiaW52b2tlRm9ybWF0dGVyIiwic3RyaW5naWZ5IiwiZm9ybWF0dGVyIiwiRm9ybWF0dGVyIiwiZm9ybWF0cyIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiZGF0ZXRpbWUiLCJEYXRlVGltZUZvcm1hdCIsInJlbGF0aXZldGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImxpc3QiLCJMaXN0Rm9ybWF0IiwiYWRkIiwiYWRkQ2FjaGVkIiwibWVtIiwiZm9ybWF0dGVkIiwidmFsT3B0aW9ucyIsImZvcm1hdFBhcmFtcyIsImxvY2FsZSIsInJlbW92ZVBlbmRpbmciLCJxIiwicGVuZGluZyIsInBlbmRpbmdDb3VudCIsIkNvbm5lY3RvciIsImJhY2tlbmQiLCJzdG9yZSIsIndhaXRpbmdSZWFkcyIsIm1heFBhcmFsbGVsUmVhZHMiLCJyZWFkaW5nQ2FsbHMiLCJtYXhSZXRyaWVzIiwicmV0cnlUaW1lb3V0Iiwic3RhdGUiLCJxdWV1ZSIsInF1ZXVlTG9hZCIsImxhbmd1YWdlcyIsImNhbGxiYWNrIiwidG9Mb2FkIiwidG9Mb2FkTGFuZ3VhZ2VzIiwidG9Mb2FkTmFtZXNwYWNlcyIsImhhc0FsbE5hbWVzcGFjZXMiLCJyZWxvYWQiLCJsb2FkZWQiLCJlcnJvcnMiLCJkb25lIiwibG9hZGVkS2V5cyIsInJlYWQiLCJmY05hbWUiLCJ0cmllZCIsIndhaXQiLCJyZXNvbHZlciIsIm5leHQiLCJzZXRUaW1lb3V0IiwiYmluZCIsInRoZW4iLCJjYXRjaCIsInByZXBhcmVMb2FkaW5nIiwibG9hZE9uZSIsImZhbGxiYWNrVmFsdWUiLCJpc1VwZGF0ZSIsImNsYiIsImdldCIsImluaXRJbW1lZGlhdGUiLCJwcmVsb2FkIiwicGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMiLCJyZXQiLCJ0RGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1PcHRpb25zIiwibm9vcCIsImJpbmRNZW1iZXJGdW5jdGlvbnMiLCJpbnN0IiwibWVtcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsIkkxOG4iLCJtb2R1bGVzIiwiZXh0ZXJuYWwiLCJpc0luaXRpYWxpemVkIiwiaXNDbG9uZSIsImRlZk9wdHMiLCJjcmVhdGVDbGFzc09uRGVtYW5kIiwiQ2xhc3NPck9iamVjdCIsImx1IiwibGFuZ3VhZ2VEZXRlY3RvciIsImRldGVjdGlvbiIsInN0b3JlQXBpIiwic3RvcmVBcGlDaGFpbmVkIiwiZGVmZXJyZWQiLCJmaW5pc2giLCJpbml0aWFsaXplZFN0b3JlT25jZSIsImxvYWRSZXNvdXJjZXMiLCJ1c2VkQ2FsbGJhY2siLCJhcHBlbmQiLCJyZXNvbHZlZExhbmd1YWdlIiwic2V0UmVzb2x2ZWRMYW5ndWFnZSIsInJlbG9hZFJlc291cmNlcyIsInVzZSIsIkVycm9yIiwibGkiLCJsbmdJbkxuZ3MiLCJfdGhpczIiLCJpc0xhbmd1YWdlQ2hhbmdpbmdUbyIsInNldExuZ1Byb3BzIiwic2V0TG5nIiwiY2FjaGVVc2VyTGFuZ3VhZ2UiLCJhc3luYyIsImRldGVjdCIsImdldEZpeGVkVCIsImtleVByZWZpeCIsIl90aGlzMyIsImZpeGVkVCIsInJlc3VsdEtleSIsInNldERlZmF1bHROYW1lc3BhY2UiLCJsYXN0TG5nIiwibG9hZE5vdFBlbmRpbmciLCJsb2FkU3RhdGUiLCJwcmVjaGVjayIsInByZVJlc3VsdCIsImxvYWROYW1lc3BhY2VzIiwibG9hZExhbmd1YWdlcyIsInByZWxvYWRlZCIsIm5ld0xuZ3MiLCJkaXIiLCJydGxMbmdzIiwiY3JlYXRlSW5zdGFuY2UiLCJjbG9uZUluc3RhbmNlIiwiZm9ya1Jlc291cmNlU3RvcmUiLCJtZXJnZWRPcHRpb25zIiwibWVtYmVyc1RvQ29weSIsImluc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        if (console && console[type]) console[type].apply(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (typeof args[0] === \"string\") args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            this.observers[event] = this.observers[event] || [];\n            this.observers[event].push(listener);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event] = this.observers[event].filter((l)=>l !== listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = [].concat(this.observers[event]);\n            cloned.forEach((observer)=>{\n                observer(...args);\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = [].concat(this.observers[\"*\"]);\n            cloned.forEach((observer)=>{\n                observer.apply(observer, [\n                    event,\n                    ...args\n                ]);\n            });\n        }\n    }\n}\nfunction defer() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n}\nfunction makeString(object) {\n    if (object == null) return \"\";\n    return \"\" + object;\n}\nfunction copy(a, s, t) {\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n}\nfunction getLastOfPath(object, path, Empty) {\n    function cleanKey(key) {\n        return key && key.indexOf(\"###\") > -1 ? key.replace(/###/g, \".\") : key;\n    }\n    function canNotTraverseDeeper() {\n        return !object || typeof object === \"string\";\n    }\n    const stack = typeof path !== \"string\" ? [].concat(path) : path.split(\".\");\n    while(stack.length > 1){\n        if (canNotTraverseDeeper()) return {};\n        const key = cleanKey(stack.shift());\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n    }\n    if (canNotTraverseDeeper()) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack.shift())\n    };\n}\nfunction setPath(object, path, newValue) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    if (concat) obj[k] = obj[k].concat(newValue);\n    if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (typeof target[prop] === \"string\" || target[prop] instanceof String || typeof source[prop] === \"string\" || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n}\nfunction regexEscape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nfunction escape(data) {\n    if (typeof data === \"string\") {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = new RegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n}\nfunction deepFind(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) return obj[path];\n    const paths = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < paths.length; ++i){\n        if (!current) return undefined;\n        if (typeof current[paths[i]] === \"string\" && i + 1 < paths.length) {\n            return undefined;\n        }\n        if (current[paths[i]] === undefined) {\n            let j = 2;\n            let p = paths.slice(i, i + j).join(keySeparator);\n            let mix = current[p];\n            while(mix === undefined && paths.length > i + j){\n                j++;\n                p = paths.slice(i, i + j).join(keySeparator);\n                mix = current[p];\n            }\n            if (mix === undefined) return undefined;\n            if (mix === null) return null;\n            if (path.endsWith(p)) {\n                if (typeof mix === \"string\") return mix;\n                if (p && typeof mix[p] === \"string\") return mix[p];\n            }\n            const joinedPath = paths.slice(i + j).join(keySeparator);\n            if (joinedPath) return deepFind(mix, joinedPath, keySeparator);\n            return undefined;\n        }\n        current = current[paths[i]];\n    }\n    return current;\n}\nfunction getCleanedCode(code) {\n    if (code && code.indexOf(\"_\") > 0) return code.replace(\"_\", \"-\");\n    return code;\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key && typeof key !== \"string\") path = path.concat(key);\n        if (key && typeof key === \"string\") path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        }\n        const result = getPath(this.data, path);\n        if (result || !ignoreJSONStructure || typeof key !== \"string\") return result;\n        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (typeof resources[m] === \"string\" || Object.prototype.toString.apply(resources[m]) === \"[object Array]\") this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        if (this.options.compatibilityAPI === \"v1\") return {\n            ...{},\n            ...this.getResource(lng, ns)\n        };\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key === undefined || key === null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved && resolved.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        return {\n            key,\n            namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys === undefined || keys === null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng && lng.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved && resolved.res;\n        const resUsedKey = resolved && resolved.usedKey || key;\n        const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n        const resType = Object.prototype.toString.apply(res);\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const handleAsObject = typeof res !== \"string\" && typeof res !== \"boolean\" && typeof res !== \"number\";\n        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === \"string\" && resType === \"[object Array]\")) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n                    ...options,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = resType === \"[object Array]\";\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in res){\n                    if (Object.prototype.hasOwnProperty.call(res, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        copy[m] = this.translate(deepKey, {\n                            ...options,\n                            ...{\n                                joinArrays: false,\n                                ns: namespaces\n                            }\n                        });\n                        if (copy[m] === deepKey) copy[m] = res[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && typeof joinArrays === \"string\" && resType === \"[object Array]\") {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const hasDefaultValue = Translator.hasDefaultValue(options);\n            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n            const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n                ordinal: false\n            }) : \"\";\n            const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            this.pluralResolver.getSuffixes(language, options).forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                if (this.options.compatibilityAPI !== \"v1\") {\n                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n                } else {\n                    res = this.options.parseMissingKeyHandler(res);\n                }\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat && this.i18nFormat.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = typeof res === \"string\" && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && typeof options.replace !== \"string\" ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && this.options.compatibilityAPI !== \"v1\" && resolved && resolved.res) options.lng = resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey && lastKey[0] === args[0] && !options.context) {\n                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = typeof postProcess === \"string\" ? [\n            postProcess\n        ] : postProcess;\n        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (typeof keys === \"string\") keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const needsContextHandling = options.context !== undefined && (typeof options.context === \"string\" || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && typeof options.replace !== \"string\";\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (typeof code === \"string\" && code.indexOf(\"-\") > -1) {\n            const specialCases = [\n                \"hans\",\n                \"hant\",\n                \"latn\",\n                \"cyrl\",\n                \"cans\",\n                \"mong\",\n                \"arab\"\n            ];\n            let p = code.split(\"-\");\n            if (this.options.lowerCaseLng) {\n                p = p.map((part)=>part.toLowerCase());\n            } else if (p.length === 2) {\n                p[0] = p[0].toLowerCase();\n                p[1] = p[1].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n            } else if (p.length === 3) {\n                p[0] = p[0].toLowerCase();\n                if (p[1].length === 2) p[1] = p[1].toUpperCase();\n                if (p[0] !== \"sgn\" && p[2].length === 2) p[2] = p[2].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n            }\n            return p.join(\"-\");\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (typeof fallbacks === \"string\") fallbacks = [\n            fallbacks\n        ];\n        if (Object.prototype.toString.apply(fallbacks) === \"[object Array]\") return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (typeof code === \"string\" && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (typeof code === \"string\") {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nlet sets = [\n    {\n        lngs: [\n            \"ach\",\n            \"ak\",\n            \"am\",\n            \"arn\",\n            \"br\",\n            \"fil\",\n            \"gun\",\n            \"ln\",\n            \"mfe\",\n            \"mg\",\n            \"mi\",\n            \"oc\",\n            \"pt\",\n            \"pt-BR\",\n            \"tg\",\n            \"tl\",\n            \"ti\",\n            \"tr\",\n            \"uz\",\n            \"wa\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 1\n    },\n    {\n        lngs: [\n            \"af\",\n            \"an\",\n            \"ast\",\n            \"az\",\n            \"bg\",\n            \"bn\",\n            \"ca\",\n            \"da\",\n            \"de\",\n            \"dev\",\n            \"el\",\n            \"en\",\n            \"eo\",\n            \"es\",\n            \"et\",\n            \"eu\",\n            \"fi\",\n            \"fo\",\n            \"fur\",\n            \"fy\",\n            \"gl\",\n            \"gu\",\n            \"ha\",\n            \"hi\",\n            \"hu\",\n            \"hy\",\n            \"ia\",\n            \"it\",\n            \"kk\",\n            \"kn\",\n            \"ku\",\n            \"lb\",\n            \"mai\",\n            \"ml\",\n            \"mn\",\n            \"mr\",\n            \"nah\",\n            \"nap\",\n            \"nb\",\n            \"ne\",\n            \"nl\",\n            \"nn\",\n            \"no\",\n            \"nso\",\n            \"pa\",\n            \"pap\",\n            \"pms\",\n            \"ps\",\n            \"pt-PT\",\n            \"rm\",\n            \"sco\",\n            \"se\",\n            \"si\",\n            \"so\",\n            \"son\",\n            \"sq\",\n            \"sv\",\n            \"sw\",\n            \"ta\",\n            \"te\",\n            \"tk\",\n            \"ur\",\n            \"yo\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ay\",\n            \"bo\",\n            \"cgg\",\n            \"fa\",\n            \"ht\",\n            \"id\",\n            \"ja\",\n            \"jbo\",\n            \"ka\",\n            \"km\",\n            \"ko\",\n            \"ky\",\n            \"lo\",\n            \"ms\",\n            \"sah\",\n            \"su\",\n            \"th\",\n            \"tt\",\n            \"ug\",\n            \"vi\",\n            \"wo\",\n            \"zh\"\n        ],\n        nr: [\n            1\n        ],\n        fc: 3\n    },\n    {\n        lngs: [\n            \"be\",\n            \"bs\",\n            \"cnr\",\n            \"dz\",\n            \"hr\",\n            \"ru\",\n            \"sr\",\n            \"uk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 4\n    },\n    {\n        lngs: [\n            \"ar\"\n        ],\n        nr: [\n            0,\n            1,\n            2,\n            3,\n            11,\n            100\n        ],\n        fc: 5\n    },\n    {\n        lngs: [\n            \"cs\",\n            \"sk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 6\n    },\n    {\n        lngs: [\n            \"csb\",\n            \"pl\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 7\n    },\n    {\n        lngs: [\n            \"cy\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            8\n        ],\n        fc: 8\n    },\n    {\n        lngs: [\n            \"fr\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 9\n    },\n    {\n        lngs: [\n            \"ga\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            7,\n            11\n        ],\n        fc: 10\n    },\n    {\n        lngs: [\n            \"gd\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            20\n        ],\n        fc: 11\n    },\n    {\n        lngs: [\n            \"is\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 12\n    },\n    {\n        lngs: [\n            \"jv\"\n        ],\n        nr: [\n            0,\n            1\n        ],\n        fc: 13\n    },\n    {\n        lngs: [\n            \"kw\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            4\n        ],\n        fc: 14\n    },\n    {\n        lngs: [\n            \"lt\"\n        ],\n        nr: [\n            1,\n            2,\n            10\n        ],\n        fc: 15\n    },\n    {\n        lngs: [\n            \"lv\"\n        ],\n        nr: [\n            1,\n            2,\n            0\n        ],\n        fc: 16\n    },\n    {\n        lngs: [\n            \"mk\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 17\n    },\n    {\n        lngs: [\n            \"mnk\"\n        ],\n        nr: [\n            0,\n            1,\n            2\n        ],\n        fc: 18\n    },\n    {\n        lngs: [\n            \"mt\"\n        ],\n        nr: [\n            1,\n            2,\n            11,\n            20\n        ],\n        fc: 19\n    },\n    {\n        lngs: [\n            \"or\"\n        ],\n        nr: [\n            2,\n            1\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ro\"\n        ],\n        nr: [\n            1,\n            2,\n            20\n        ],\n        fc: 20\n    },\n    {\n        lngs: [\n            \"sl\"\n        ],\n        nr: [\n            5,\n            1,\n            2,\n            3\n        ],\n        fc: 21\n    },\n    {\n        lngs: [\n            \"he\",\n            \"iw\"\n        ],\n        nr: [\n            1,\n            2,\n            20,\n            21\n        ],\n        fc: 22\n    }\n];\nlet _rulesPluralsTypes = {\n    1: function(n) {\n        return Number(n > 1);\n    },\n    2: function(n) {\n        return Number(n != 1);\n    },\n    3: function(n) {\n        return 0;\n    },\n    4: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    5: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n    },\n    6: function(n) {\n        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n    },\n    7: function(n) {\n        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    8: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n    },\n    9: function(n) {\n        return Number(n >= 2);\n    },\n    10: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n    },\n    11: function(n) {\n        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n    },\n    12: function(n) {\n        return Number(n % 10 != 1 || n % 100 == 11);\n    },\n    13: function(n) {\n        return Number(n !== 0);\n    },\n    14: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n    },\n    15: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    16: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n    },\n    17: function(n) {\n        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n    },\n    18: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n    },\n    19: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n    },\n    20: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n    },\n    21: function(n) {\n        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n    },\n    22: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n    }\n};\nconst nonIntlVersions = [\n    \"v1\",\n    \"v2\",\n    \"v3\"\n];\nconst intlVersions = [\n    \"v4\"\n];\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nfunction createRules() {\n    const rules = {};\n    sets.forEach((set)=>{\n        set.lngs.forEach((l)=>{\n            rules[l] = {\n                numbers: set.nr,\n                plurals: _rulesPluralsTypes[set.fc]\n            };\n        });\n    });\n    return rules;\n}\nclass PluralResolver {\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === \"undefined\" || !Intl.PluralRules)) {\n            this.options.compatibilityJSON = \"v3\";\n            this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\");\n        }\n        this.rules = createRules();\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.shouldUseIntlApi()) {\n            try {\n                return new Intl.PluralRules(getCleanedCode(code), {\n                    type: options.ordinal ? \"ordinal\" : \"cardinal\"\n                });\n            } catch (err) {\n                return;\n            }\n        }\n        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (this.shouldUseIntlApi()) {\n            return rule && rule.resolvedOptions().pluralCategories.length > 1;\n        }\n        return rule && rule.numbers.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (!rule) {\n            return [];\n        }\n        if (this.shouldUseIntlApi()) {\n            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n        }\n        return rule.numbers.map((number)=>this.getSuffix(code, number, options));\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            if (this.shouldUseIntlApi()) {\n                return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n            }\n            return this.getSuffixRetroCompatible(rule, count);\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return \"\";\n    }\n    getSuffixRetroCompatible(rule, count) {\n        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        let suffix = rule.numbers[idx];\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            if (suffix === 2) {\n                suffix = \"plural\";\n            } else if (suffix === 1) {\n                suffix = \"\";\n            }\n        }\n        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n        if (this.options.compatibilityJSON === \"v1\") {\n            if (suffix === 1) return \"\";\n            if (typeof suffix === \"number\") return `_plural_${suffix.toString()}`;\n            return returnSuffix();\n        } else if (this.options.compatibilityJSON === \"v2\") {\n            return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            return returnSuffix();\n        }\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n    shouldUseIntlApi() {\n        return !nonIntlVersions.includes(this.options.compatibilityJSON);\n    }\n}\nfunction deepFindWithDefaults(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && typeof key === \"string\") {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n}\nclass Interpolator {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options.interpolation && options.interpolation.format || ((value)=>value);\n        this.init(options);\n    }\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const iOpts = options.interpolation;\n        this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n        this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n        this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || \"{{\";\n        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || \"}}\";\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n        this.unescapePrefix = iOpts.unescapeSuffix ? \"\" : iOpts.unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : iOpts.unescapeSuffix || \"\";\n        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || \",\";\n        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n        this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const regexpStr = `${this.prefix}(.+?)${this.suffix}`;\n        this.regexp = new RegExp(regexpStr, \"g\");\n        const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;\n        this.regexpUnescape = new RegExp(regexpUnescapeStr, \"g\");\n        const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;\n        this.nestingRegexp = new RegExp(nestingRegexpStr, \"g\");\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        function regexSafe(val) {\n            return val.replace(/\\$/g, \"$$$$\");\n        }\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = typeof temp === \"string\" ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (typeof value !== \"string\" && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        function handleHasOptions(key, inheritedOptions) {\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            delete clonedOptions.defaultValue;\n            return key;\n        }\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== \"string\" ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && typeof value !== \"string\") return value;\n            if (typeof value !== \"string\") value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nfunction parseFormatStr(formatStr) {\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (!opt) return;\n                const [key, ...rest] = opt.split(\":\");\n                const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;\n                if (val === \"false\") formatOptions[key.trim()] = false;\n                if (val === \"true\") formatOptions[key.trim()] = true;\n                if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n}\nfunction createCachedFormatter(fn) {\n    const cache = {};\n    return function invokeFormatter(val, lng, options) {\n        const key = lng + JSON.stringify(options);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n}\nclass Formatter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        const iOpts = options.interpolation;\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nfunction removePending(q, name) {\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n}\nclass Connector extends EventEmitter {\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        if (this.backend && this.backend.init) {\n            this.backend.init(services, options.backend, options);\n        }\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (data) {\n            this.store.addResourceBundle(lng, ns, data);\n        }\n        this.state[name] = err ? -1 : 2;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (typeof languages === \"string\") languages = this.languageUtils.toResolveHierarchy(languages);\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend && this.backend.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nfunction get() {\n    return {\n        debug: false,\n        initImmediate: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: function handle(args) {\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (typeof args[1] === \"string\") ret.defaultValue = args[1];\n            if (typeof args[2] === \"string\") ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    };\n}\nfunction transformOptions(options) {\n    if (typeof options.ns === \"string\") options.ns = [\n        options.ns\n    ];\n    if (typeof options.fallbackLng === \"string\") options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (typeof options.fallbackNS === \"string\") options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs && options.supportedLngs.indexOf(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    return options;\n}\nfunction noop() {}\nfunction bindMemberFunctions(inst) {\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n}\nclass I18n extends EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initImmediate) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n            if (typeof options.ns === \"string\") {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        if (this.options.compatibilityAPI !== \"v1\") {\n            this.options.interpolation = {\n                ...defOpts.interpolation,\n                ...this.options.interpolation\n            };\n        }\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        function createClassOnDemand(ClassOrObject) {\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        }\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else if (typeof Intl !== \"undefined\") {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                compatibilityJSON: this.options.compatibilityJSON,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && this.options.compatibilityAPI !== \"v1\" && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initImmediate) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = typeof language === \"string\" ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng && usedLng.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            if (this.options.preload) {\n                this.options.preload.forEach((l)=>append(l));\n            }\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = typeof lngs === \"string\" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${options.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (typeof lng === \"string\") {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        return this.translator && this.translator.translate(...arguments);\n    }\n    exists() {\n        return this.translator && this.translator.exists(...arguments);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (typeof ns === \"string\") ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"string\") lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0);\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            clone.store = new ResourceStore(this.store.data, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n                args[_key4 - 1] = arguments[_key4];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLGdCQUFnQjtJQUNwQkMsTUFBTTtJQUNOQyxLQUFJQyxJQUFJO1FBQ04sSUFBSSxDQUFDQyxNQUFNLENBQUMsT0FBT0Q7SUFDckI7SUFDQUUsTUFBS0YsSUFBSTtRQUNQLElBQUksQ0FBQ0MsTUFBTSxDQUFDLFFBQVFEO0lBQ3RCO0lBQ0FHLE9BQU1ILElBQUk7UUFDUixJQUFJLENBQUNDLE1BQU0sQ0FBQyxTQUFTRDtJQUN2QjtJQUNBQyxRQUFPSCxJQUFJLEVBQUVFLElBQUk7UUFDZixJQUFJSSxXQUFXQSxPQUFPLENBQUNOLEtBQUssRUFBRU0sT0FBTyxDQUFDTixLQUFLLENBQUNPLEtBQUssQ0FBQ0QsU0FBU0o7SUFDN0Q7QUFDRjtBQUNBLE1BQU1NO0lBQ0pDLFlBQVlDLGNBQWMsQ0FBRTtRQUMxQixJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUksQ0FBQ0csSUFBSSxDQUFDTCxnQkFBZ0JDO0lBQzVCO0lBQ0FJLEtBQUtMLGNBQWMsRUFBRTtRQUNuQixJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUksQ0FBQ0ksTUFBTSxHQUFHTCxRQUFRSyxNQUFNLElBQUk7UUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUdQLGtCQUFrQlg7UUFDaEMsSUFBSSxDQUFDWSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDTyxLQUFLLEdBQUdQLFFBQVFPLEtBQUs7SUFDNUI7SUFDQWpCLE1BQU07UUFDSixJQUFLLElBQUlrQixPQUFPUCxVQUFVQyxNQUFNLEVBQUVYLE9B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VyxTQUFTWCxjQUFjO0FBQzlDLE1BQU1DLGdCQUFnQlUsU0FBU1YsYUFBYTtBQUVpSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Fyc2hpYS8uL25vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvZXNtL2kxOG5leHQuanM/NjhlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb25zb2xlTG9nZ2VyID0ge1xuICB0eXBlOiAnbG9nZ2VyJyxcbiAgbG9nKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnbG9nJywgYXJncyk7XG4gIH0sXG4gIHdhcm4oYXJncykge1xuICAgIHRoaXMub3V0cHV0KCd3YXJuJywgYXJncyk7XG4gIH0sXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnZXJyb3InLCBhcmdzKTtcbiAgfSxcbiAgb3V0cHV0KHR5cGUsIGFyZ3MpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlW3R5cGVdKSBjb25zb2xlW3R5cGVdLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uY3JldGVMb2dnZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5pbml0KGNvbmNyZXRlTG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBpbml0KGNvbmNyZXRlTG9nZ2VyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgJ2kxOG5leHQ6JztcbiAgICB0aGlzLmxvZ2dlciA9IGNvbmNyZXRlTG9nZ2VyIHx8IGNvbnNvbGVMb2dnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgfVxuICBsb2coKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdsb2cnLCAnJywgdHJ1ZSk7XG4gIH1cbiAgd2FybigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICcnLCB0cnVlKTtcbiAgfVxuICBlcnJvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnZXJyb3InLCAnJyk7XG4gIH1cbiAgZGVwcmVjYXRlKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJ1dBUk5JTkcgREVQUkVDQVRFRDogJywgdHJ1ZSk7XG4gIH1cbiAgZm9yd2FyZChhcmdzLCBsdmwsIHByZWZpeCwgZGVidWdPbmx5KSB7XG4gICAgaWYgKGRlYnVnT25seSAmJiAhdGhpcy5kZWJ1ZykgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykgYXJnc1swXSA9IGAke3ByZWZpeH0ke3RoaXMucHJlZml4fSAke2FyZ3NbMF19YDtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJbbHZsXShhcmdzKTtcbiAgfVxuICBjcmVhdGUobW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCB7XG4gICAgICAuLi57XG4gICAgICAgIHByZWZpeDogYCR7dGhpcy5wcmVmaXh9OiR7bW9kdWxlTmFtZX06YFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNsb25lKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnM7XG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCB0aGlzLnByZWZpeDtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbn1cbnZhciBiYXNlTG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50cywgbGlzdGVuZXIpIHtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSA9IHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHJldHVybjtcbiAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbZXZlbnRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyc1tldmVudF0gPSB0aGlzLm9ic2VydmVyc1tldmVudF0uZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICB9XG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gW10uY29uY2F0KHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyKC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1snKiddKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBbXS5jb25jYXQodGhpcy5vYnNlcnZlcnNbJyonXSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnQsIC4uLmFyZ3NdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgbGV0IHJlcztcbiAgbGV0IHJlajtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXMgPSByZXNvbHZlO1xuICAgIHJlaiA9IHJlamVjdDtcbiAgfSk7XG4gIHByb21pc2UucmVzb2x2ZSA9IHJlcztcbiAgcHJvbWlzZS5yZWplY3QgPSByZWo7XG4gIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZVN0cmluZyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gJyc7XG4gIHJldHVybiAnJyArIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGNvcHkoYSwgcywgdCkge1xuICBhLmZvckVhY2gobSA9PiB7XG4gICAgaWYgKHNbbV0pIHRbbV0gPSBzW21dO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBFbXB0eSkge1xuICBmdW5jdGlvbiBjbGVhbktleShrZXkpIHtcbiAgICByZXR1cm4ga2V5ICYmIGtleS5pbmRleE9mKCcjIyMnKSA+IC0xID8ga2V5LnJlcGxhY2UoLyMjIy9nLCAnLicpIDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGNhbk5vdFRyYXZlcnNlRGVlcGVyKCkge1xuICAgIHJldHVybiAhb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnO1xuICB9XG4gIGNvbnN0IHN0YWNrID0gdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnID8gW10uY29uY2F0KHBhdGgpIDogcGF0aC5zcGxpdCgnLicpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcigpKSByZXR1cm4ge307XG4gICAgY29uc3Qga2V5ID0gY2xlYW5LZXkoc3RhY2suc2hpZnQoKSk7XG4gICAgaWYgKCFvYmplY3Rba2V5XSAmJiBFbXB0eSkgb2JqZWN0W2tleV0gPSBuZXcgRW1wdHkoKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAoY2FuTm90VHJhdmVyc2VEZWVwZXIoKSkgcmV0dXJuIHt9O1xuICByZXR1cm4ge1xuICAgIG9iajogb2JqZWN0LFxuICAgIGs6IGNsZWFuS2V5KHN0YWNrLnNoaWZ0KCkpXG4gIH07XG59XG5mdW5jdGlvbiBzZXRQYXRoKG9iamVjdCwgcGF0aCwgbmV3VmFsdWUpIHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgb2JqW2tdID0gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiBwdXNoUGF0aChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlLCBjb25jYXQpIHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgb2JqW2tdID0gb2JqW2tdIHx8IFtdO1xuICBpZiAoY29uY2F0KSBvYmpba10gPSBvYmpba10uY29uY2F0KG5ld1ZhbHVlKTtcbiAgaWYgKCFjb25jYXQpIG9ialtrXS5wdXNoKG5ld1ZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldFBhdGgob2JqZWN0LCBwYXRoKSB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgpO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG9ialtrXTtcbn1cbmZ1bmN0aW9uIGdldFBhdGhXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFBhdGgoZGF0YSwga2V5KTtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdldFBhdGgoZGVmYXVsdERhdGEsIGtleSk7XG59XG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIGlmIChwcm9wICE9PSAnX19wcm90b19fJyAmJiBwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHRhcmdldFtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygc291cmNlW3Byb3BdID09PSAnc3RyaW5nJyB8fCBzb3VyY2VbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICBpZiAob3ZlcndyaXRlKSB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcmVnZXhFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbn1cbnZhciBfZW50aXR5TWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnLFxuICAnLyc6ICcmI3gyRjsnXG59O1xuZnVuY3Rpb24gZXNjYXBlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIHMgPT4gX2VudGl0eU1hcFtzXSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5jb25zdCBjaGFycyA9IFsnICcsICcsJywgJz8nLCAnIScsICc7J107XG5mdW5jdGlvbiBsb29rc0xpa2VPYmplY3RQYXRoKGtleSwgbnNTZXBhcmF0b3IsIGtleVNlcGFyYXRvcikge1xuICBuc1NlcGFyYXRvciA9IG5zU2VwYXJhdG9yIHx8ICcnO1xuICBrZXlTZXBhcmF0b3IgPSBrZXlTZXBhcmF0b3IgfHwgJyc7XG4gIGNvbnN0IHBvc3NpYmxlQ2hhcnMgPSBjaGFycy5maWx0ZXIoYyA9PiBuc1NlcGFyYXRvci5pbmRleE9mKGMpIDwgMCAmJiBrZXlTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDApO1xuICBpZiAocG9zc2libGVDaGFycy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBjb25zdCByID0gbmV3IFJlZ0V4cChgKCR7cG9zc2libGVDaGFycy5tYXAoYyA9PiBjID09PSAnPycgPyAnXFxcXD8nIDogYykuam9pbignfCcpfSlgKTtcbiAgbGV0IG1hdGNoZWQgPSAhci50ZXN0KGtleSk7XG4gIGlmICghbWF0Y2hlZCkge1xuICAgIGNvbnN0IGtpID0ga2V5LmluZGV4T2Yoa2V5U2VwYXJhdG9yKTtcbiAgICBpZiAoa2kgPiAwICYmICFyLnRlc3Qoa2V5LnN1YnN0cmluZygwLCBraSkpKSB7XG4gICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZWQ7XG59XG5mdW5jdGlvbiBkZWVwRmluZChvYmosIHBhdGgpIHtcbiAgbGV0IGtleVNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJy4nO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKG9ialtwYXRoXSkgcmV0dXJuIG9ialtwYXRoXTtcbiAgY29uc3QgcGF0aHMgPSBwYXRoLnNwbGl0KGtleVNlcGFyYXRvcik7XG4gIGxldCBjdXJyZW50ID0gb2JqO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFjdXJyZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgY3VycmVudFtwYXRoc1tpXV0gPT09ICdzdHJpbmcnICYmIGkgKyAxIDwgcGF0aHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFtwYXRoc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGogPSAyO1xuICAgICAgbGV0IHAgPSBwYXRocy5zbGljZShpLCBpICsgaikuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgICAgbGV0IG1peCA9IGN1cnJlbnRbcF07XG4gICAgICB3aGlsZSAobWl4ID09PSB1bmRlZmluZWQgJiYgcGF0aHMubGVuZ3RoID4gaSArIGopIHtcbiAgICAgICAgaisrO1xuICAgICAgICBwID0gcGF0aHMuc2xpY2UoaSwgaSArIGopLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICAgICAgbWl4ID0gY3VycmVudFtwXTtcbiAgICAgIH1cbiAgICAgIGlmIChtaXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGlmIChtaXggPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHBhdGguZW5kc1dpdGgocCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnKSByZXR1cm4gbWl4O1xuICAgICAgICBpZiAocCAmJiB0eXBlb2YgbWl4W3BdID09PSAnc3RyaW5nJykgcmV0dXJuIG1peFtwXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvaW5lZFBhdGggPSBwYXRocy5zbGljZShpICsgaikuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgICAgaWYgKGpvaW5lZFBhdGgpIHJldHVybiBkZWVwRmluZChtaXgsIGpvaW5lZFBhdGgsIGtleVNlcGFyYXRvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoc1tpXV07XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBnZXRDbGVhbmVkQ29kZShjb2RlKSB7XG4gIGlmIChjb2RlICYmIGNvZGUuaW5kZXhPZignXycpID4gMCkgcmV0dXJuIGNvZGUucmVwbGFjZSgnXycsICctJyk7XG4gIHJldHVybiBjb2RlO1xufVxuXG5jbGFzcyBSZXNvdXJjZVN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBuczogWyd0cmFuc2xhdGlvbiddLFxuICAgICAgZGVmYXVsdE5TOiAndHJhbnNsYXRpb24nXG4gICAgfTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhZGROYW1lc3BhY2VzKG5zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5wdXNoKG5zKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTmFtZXNwYWNlcyhucykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcHRpb25zLm5zLmluZGV4T2YobnMpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVzb3VyY2UobG5nLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3QgaWdub3JlSlNPTlN0cnVjdHVyZSA9IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlIDogdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmU7XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGguY29uY2F0KGtleSk7XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKTtcbiAgICBpZiAocmVzdWx0IHx8ICFpZ25vcmVKU09OU3RydWN0dXJlIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBkZWVwRmluZCh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW2xuZ10gJiYgdGhpcy5kYXRhW2xuZ11bbnNdLCBrZXksIGtleVNlcGFyYXRvcik7XG4gIH1cbiAgYWRkUmVzb3VyY2UobG5nLCBucywga2V5LCB2YWx1ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChrZXkpIHBhdGggPSBwYXRoLmNvbmNhdChrZXlTZXBhcmF0b3IgPyBrZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSA6IGtleSk7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgICAgdmFsdWUgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBzZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgdmFsdWUpO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCBrZXksIHZhbHVlKTtcbiAgfVxuICBhZGRSZXNvdXJjZXMobG5nLCBucywgcmVzb3VyY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2VzW21dID09PSAnc3RyaW5nJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlc291cmNlc1ttXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHRoaXMuYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dLCB7XG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIGFkZFJlc291cmNlQnVuZGxlKGxuZywgbnMsIHJlc291cmNlcywgZGVlcCwgb3ZlcndyaXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIGRlZXAgPSByZXNvdXJjZXM7XG4gICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBsZXQgcGFjayA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKSB8fCB7fTtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgZGVlcEV4dGVuZChwYWNrLCByZXNvdXJjZXMsIG92ZXJ3cml0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2sgPSB7XG4gICAgICAgIC4uLnBhY2ssXG4gICAgICAgIC4uLnJlc291cmNlc1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHBhY2spO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIHJlbW92ZVJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtsbmddW25zXTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVOYW1lc3BhY2VzKG5zKTtcbiAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCBsbmcsIG5zKTtcbiAgfVxuICBoYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucykgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSA9PT0gJ3YxJykgcmV0dXJuIHtcbiAgICAgIC4uLnt9LFxuICAgICAgLi4udGhpcy5nZXRSZXNvdXJjZShsbmcsIG5zKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucyk7XG4gIH1cbiAgZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtsbmddO1xuICB9XG4gIGhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmcpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhQnlMYW5ndWFnZShsbmcpO1xuICAgIGNvbnN0IG4gPSBkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpIHx8IFtdO1xuICAgIHJldHVybiAhIW4uZmluZCh2ID0+IGRhdGFbdl0gJiYgT2JqZWN0LmtleXMoZGF0YVt2XSkubGVuZ3RoID4gMCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxudmFyIHBvc3RQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NvcnM6IHt9LFxuICBhZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSkge1xuICAgIHRoaXMucHJvY2Vzc29yc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG4gIH0sXG4gIGhhbmRsZShwcm9jZXNzb3JzLCB2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKSB7XG4gICAgcHJvY2Vzc29ycy5mb3JFYWNoKHByb2Nlc3NvciA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0pIHZhbHVlID0gdGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0ucHJvY2Vzcyh2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbmNvbnN0IGNoZWNrZWRMb2FkZWRGb3IgPSB7fTtcbmNsYXNzIFRyYW5zbGF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIGNvcHkoWydyZXNvdXJjZVN0b3JlJywgJ2xhbmd1YWdlVXRpbHMnLCAncGx1cmFsUmVzb2x2ZXInLCAnaW50ZXJwb2xhdG9yJywgJ2JhY2tlbmRDb25uZWN0b3InLCAnaTE4bkZvcm1hdCcsICd1dGlscyddLCBzZXJ2aWNlcywgdGhpcyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCd0cmFuc2xhdG9yJyk7XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nKSB7XG4gICAgaWYgKGxuZykgdGhpcy5sYW5ndWFnZSA9IGxuZztcbiAgfVxuICBleGlzdHMoa2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGludGVycG9sYXRpb246IHt9XG4gICAgfTtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKGtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGV4dHJhY3RGcm9tS2V5KGtleSwgb3B0aW9ucykge1xuICAgIGxldCBuc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgaWYgKG5zU2VwYXJhdG9yID09PSB1bmRlZmluZWQpIG5zU2VwYXJhdG9yID0gJzonO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IG5hbWVzcGFjZXMgPSBvcHRpb25zLm5zIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgfHwgW107XG4gICAgY29uc3Qgd291bGRDaGVja0Zvck5zSW5LZXkgPSBuc1NlcGFyYXRvciAmJiBrZXkuaW5kZXhPZihuc1NlcGFyYXRvcikgPiAtMTtcbiAgICBjb25zdCBzZWVtc05hdHVyYWxMYW5ndWFnZSA9ICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgJiYgIW9wdGlvbnMua2V5U2VwYXJhdG9yICYmICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciAmJiAhb3B0aW9ucy5uc1NlcGFyYXRvciAmJiAhbG9va3NMaWtlT2JqZWN0UGF0aChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmICh3b3VsZENoZWNrRm9yTnNJbktleSAmJiAhc2VlbXNOYXR1cmFsTGFuZ3VhZ2UpIHtcbiAgICAgIGNvbnN0IG0gPSBrZXkubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZXNwYWNlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQobnNTZXBhcmF0b3IpO1xuICAgICAgaWYgKG5zU2VwYXJhdG9yICE9PSBrZXlTZXBhcmF0b3IgfHwgbnNTZXBhcmF0b3IgPT09IGtleVNlcGFyYXRvciAmJiB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihwYXJ0c1swXSkgPiAtMSkgbmFtZXNwYWNlcyA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBrZXkgPSBwYXJ0cy5qb2luKGtleVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXNcbiAgICB9O1xuICB9XG4gIHRyYW5zbGF0ZShrZXlzLCBvcHRpb25zLCBsYXN0S2V5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cyA9PT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHRpb25zLnJldHVybkRldGFpbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmV0dXJuRGV0YWlscyA6IHRoaXMub3B0aW9ucy5yZXR1cm5EZXRhaWxzO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlc1xuICAgIH0gPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2U7XG4gICAgY29uc3QgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUgPSBvcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nICYmIGxuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGNvbnN0IG5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzOiBrZXksXG4gICAgICAgICAgdXNlZEtleToga2V5LFxuICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgIHVzZWRMbmc6IGxuZyxcbiAgICAgICAgICB1c2VkTlM6IG5hbWVzcGFjZSxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXlzLCBvcHRpb25zKTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzO1xuICAgIGNvbnN0IHJlc1VzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC51c2VkS2V5IHx8IGtleTtcbiAgICBjb25zdCByZXNFeGFjdFVzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlcyk7XG4gICAgY29uc3Qgbm9PYmplY3QgPSBbJ1tvYmplY3QgTnVtYmVyXScsICdbb2JqZWN0IEZ1bmN0aW9uXScsICdbb2JqZWN0IFJlZ0V4cF0nXTtcbiAgICBjb25zdCBqb2luQXJyYXlzID0gb3B0aW9ucy5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmpvaW5BcnJheXMgOiB0aGlzLm9wdGlvbnMuam9pbkFycmF5cztcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCA9ICF0aGlzLmkxOG5Gb3JtYXQgfHwgdGhpcy5pMThuRm9ybWF0LmhhbmRsZUFzT2JqZWN0O1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0ID0gdHlwZW9mIHJlcyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHJlcyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZXMgIT09ICdudW1iZXInO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXMgJiYgaGFuZGxlQXNPYmplY3QgJiYgbm9PYmplY3QuaW5kZXhPZihyZXNUeXBlKSA8IDAgJiYgISh0eXBlb2Ygam9pbkFycmF5cyA9PT0gJ3N0cmluZycgJiYgcmVzVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXR1cm5PYmplY3RzICYmICF0aGlzLm9wdGlvbnMucmV0dXJuT2JqZWN0cykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdhY2Nlc3NpbmcgYW4gb2JqZWN0IC0gYnV0IHJldHVybk9iamVjdHMgb3B0aW9ucyBpcyBub3QgZW5hYmxlZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlciA/IHRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIocmVzVXNlZEtleSwgcmVzLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICB9KSA6IGBrZXkgJyR7a2V5fSAoJHt0aGlzLmxhbmd1YWdlfSknIHJldHVybmVkIGFuIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZy5gO1xuICAgICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmVkLnJlcyA9IHI7XG4gICAgICAgICAgcmVzb2x2ZWQudXNlZFBhcmFtcyA9IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgaWYgKGtleVNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCByZXNUeXBlSXNBcnJheSA9IHJlc1R5cGUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIGNvbnN0IGNvcHkgPSByZXNUeXBlSXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGNvbnN0IG5ld0tleVRvVXNlID0gcmVzVHlwZUlzQXJyYXkgPyByZXNFeGFjdFVzZWRLZXkgOiByZXNVc2VkS2V5O1xuICAgICAgICBmb3IgKGNvbnN0IG0gaW4gcmVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXMsIG0pKSB7XG4gICAgICAgICAgICBjb25zdCBkZWVwS2V5ID0gYCR7bmV3S2V5VG9Vc2V9JHtrZXlTZXBhcmF0b3J9JHttfWA7XG4gICAgICAgICAgICBjb3B5W21dID0gdGhpcy50cmFuc2xhdGUoZGVlcEtleSwge1xuICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29weVttXSA9PT0gZGVlcEtleSkgY29weVttXSA9IHJlc1ttXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gY29weTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmIHR5cGVvZiBqb2luQXJyYXlzID09PSAnc3RyaW5nJyAmJiByZXNUeXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXMgPSByZXMuam9pbihqb2luQXJyYXlzKTtcbiAgICAgIGlmIChyZXMpIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXlzLCBvcHRpb25zLCBsYXN0S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVzZWREZWZhdWx0ID0gZmFsc2U7XG4gICAgICBsZXQgdXNlZEtleSA9IGZhbHNlO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBoYXNEZWZhdWx0VmFsdWUgPSBUcmFuc2xhdG9yLmhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVN1ZmZpeCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpIDogJyc7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2sgPSBvcHRpb25zLm9yZGluYWwgJiYgbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0aW9ucy5jb3VudCwge1xuICAgICAgICBvcmRpbmFsOiBmYWxzZVxuICAgICAgfSkgOiAnJztcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4fWBdIHx8IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSAmJiBoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdXNlZERlZmF1bHQgPSB0cnVlO1xuICAgICAgICByZXMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChyZXMpKSB7XG4gICAgICAgIHVzZWRLZXkgPSB0cnVlO1xuICAgICAgICByZXMgPSBrZXk7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgPSBvcHRpb25zLm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBrZXlTZXBhcmF0b3I6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGZrICYmIGZrLnJlcykgdGhpcy5sb2dnZXIud2FybignU2VlbXMgdGhlIGxvYWRlZCB0cmFuc2xhdGlvbnMgd2VyZSBpbiBmbGF0IEpTT04gZm9ybWF0IGluc3RlYWQgb2YgbmVzdGVkLiBFaXRoZXIgc2V0IGtleVNlcGFyYXRvcjogZmFsc2Ugb24gaW5pdCBvciBtYWtlIHN1cmUgeW91ciB0cmFuc2xhdGlvbnMgYXJlIHB1Ymxpc2hlZCBpbiBuZXN0ZWQgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsbmdzID0gW107XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrTG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZywgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2ZhbGxiYWNrJyAmJiBmYWxsYmFja0xuZ3MgJiYgZmFsbGJhY2tMbmdzWzBdKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWxsYmFja0xuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxuZ3MucHVzaChmYWxsYmFja0xuZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IChsLCBrLCBzcGVjaWZpY0RlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRGb3JNaXNzaW5nID0gaGFzRGVmYXVsdFZhbHVlICYmIHNwZWNpZmljRGVmYXVsdFZhbHVlICE9PSByZXMgPyBzcGVjaWZpY0RlZmF1bHRWYWx1ZSA6IHJlc0Zvck1pc3Npbmc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kQ29ubmVjdG9yICYmIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeGVzKGxhbmd1YWdlLCBvcHRpb25zKS5mb3JFYWNoKHN1ZmZpeCA9PiB7XG4gICAgICAgICAgICAgICAgc2VuZChbbGFuZ3VhZ2VdLCBrZXkgKyBzdWZmaXgsIG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7c3VmZml4fWBdIHx8IGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmQobG5ncywga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzID0gdGhpcy5leHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleXMsIG9wdGlvbnMsIHJlc29sdmVkLCBsYXN0S2V5KTtcbiAgICAgIGlmICh1c2VkS2V5ICYmIHJlcyA9PT0ga2V5ICYmIHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkpIHJlcyA9IGAke25hbWVzcGFjZX06JHtrZXl9YDtcbiAgICAgIGlmICgodXNlZEtleSB8fCB1c2VkRGVmYXVsdCkgJiYgdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIodGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSA/IGAke25hbWVzcGFjZX06JHtrZXl9YCA6IGtleSwgdXNlZERlZmF1bHQgPyByZXMgOiB1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgIHJlc29sdmVkLnJlcyA9IHJlcztcbiAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5LCBvcHRpb25zLCByZXNvbHZlZCwgbGFzdEtleSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQucGFyc2UpIHtcbiAgICAgIHJlcyA9IHRoaXMuaTE4bkZvcm1hdC5wYXJzZShyZXMsIHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSwgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCByZXNvbHZlZC51c2VkTlMsIHJlc29sdmVkLnVzZWRLZXksIHtcbiAgICAgICAgcmVzb2x2ZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2tpcEludGVycG9sYXRpb24pIHtcbiAgICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLmluaXQoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi57XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAuLi5vcHRpb25zLmludGVycG9sYXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2tpcE9uVmFyaWFibGVzID0gdHlwZW9mIHJlcyA9PT0gJ3N0cmluZycgJiYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMpO1xuICAgICAgbGV0IG5lc3RCZWY7XG4gICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgIGNvbnN0IG5iID0gcmVzLm1hdGNoKHRoaXMuaW50ZXJwb2xhdG9yLm5lc3RpbmdSZWdleHApO1xuICAgICAgICBuZXN0QmVmID0gbmIgJiYgbmIubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgdHlwZW9mIG9wdGlvbnMucmVwbGFjZSAhPT0gJ3N0cmluZycgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICByZXMgPSB0aGlzLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShyZXMsIGRhdGEsIG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHRpb25zLm5lc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5sbmcgJiYgdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScgJiYgcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzKSBvcHRpb25zLmxuZyA9IHJlc29sdmVkLnVzZWRMbmc7XG4gICAgICBpZiAob3B0aW9ucy5uZXN0ICE9PSBmYWxzZSkgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IubmVzdChyZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEtleSAmJiBsYXN0S2V5WzBdID09PSBhcmdzWzBdICYmICFvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihgSXQgc2VlbXMgeW91IGFyZSBuZXN0aW5nIHJlY3Vyc2l2ZWx5IGtleTogJHthcmdzWzBdfSBpbiBrZXk6ICR7a2V5WzBdfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IucmVzZXQoKTtcbiAgICB9XG4gICAgY29uc3QgcG9zdFByb2Nlc3MgPSBvcHRpb25zLnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSB0eXBlb2YgcG9zdFByb2Nlc3MgPT09ICdzdHJpbmcnID8gW3Bvc3RQcm9jZXNzXSA6IHBvc3RQcm9jZXNzO1xuICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCAmJiByZXMgIT09IG51bGwgJiYgcG9zdFByb2Nlc3Nvck5hbWVzICYmIHBvc3RQcm9jZXNzb3JOYW1lcy5sZW5ndGggJiYgb3B0aW9ucy5hcHBseVBvc3RQcm9jZXNzb3IgIT09IGZhbHNlKSB7XG4gICAgICByZXMgPSBwb3N0UHJvY2Vzc29yLmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkID8ge1xuICAgICAgICBpMThuUmVzb2x2ZWQ6IHtcbiAgICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gOiBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXNvbHZlKGtleXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGZvdW5kO1xuICAgIGxldCB1c2VkS2V5O1xuICAgIGxldCBleGFjdFVzZWRLZXk7XG4gICAgbGV0IHVzZWRMbmc7XG4gICAgbGV0IHVzZWROUztcbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdzdHJpbmcnKSBrZXlzID0gW2tleXNdO1xuICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGssIG9wdGlvbnMpO1xuICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdGVkLmtleTtcbiAgICAgIHVzZWRLZXkgPSBrZXk7XG4gICAgICBsZXQgbmFtZXNwYWNlcyA9IGV4dHJhY3RlZC5uYW1lc3BhY2VzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja05TKSBuYW1lc3BhY2VzID0gbmFtZXNwYWNlcy5jb25jYXQodGhpcy5vcHRpb25zLmZhbGxiYWNrTlMpO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMCAmJiB0aGlzLnBsdXJhbFJlc29sdmVyLnNob3VsZFVzZUludGxBcGkoKTtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0aW9ucy5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICdudW1iZXInKSAmJiBvcHRpb25zLmNvbnRleHQgIT09ICcnO1xuICAgICAgY29uc3QgY29kZXMgPSBvcHRpb25zLmxuZ3MgPyBvcHRpb25zLmxuZ3MgOiB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UsIG9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgdXNlZE5TID0gbnM7XG4gICAgICAgIGlmICghY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSAmJiB0aGlzLnV0aWxzICYmIHRoaXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZSh1c2VkTlMpKSB7XG4gICAgICAgICAgY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2Fybihga2V5IFwiJHt1c2VkS2V5fVwiIGZvciBsYW5ndWFnZXMgXCIke2NvZGVzLmpvaW4oJywgJyl9XCIgd29uJ3QgZ2V0IHJlc29sdmVkIGFzIG5hbWVzcGFjZSBcIiR7dXNlZE5TfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgICAgdXNlZExuZyA9IGNvZGU7XG4gICAgICAgICAgY29uc3QgZmluYWxLZXlzID0gW2tleV07XG4gICAgICAgICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQuYWRkTG9va3VwS2V5cykge1xuICAgICAgICAgICAgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMoZmluYWxLZXlzLCBrZXksIGNvZGUsIG5zLCBvcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBsdXJhbFN1ZmZpeDtcbiAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSBwbHVyYWxTdWZmaXggPSB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChjb2RlLCBvcHRpb25zLmNvdW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9TdWZmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gO1xuICAgICAgICAgICAgY29uc3Qgb3JkaW5hbFByZWZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9b3JkaW5hbCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1gO1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgemVyb1N1ZmZpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWVkc0NvbnRleHRIYW5kbGluZykge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZXh0S2V5ID0gYCR7a2V5fSR7dGhpcy5vcHRpb25zLmNvbnRleHRTZXBhcmF0b3J9JHtvcHRpb25zLmNvbnRleHR9YDtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzWmVyb1N1ZmZpeExvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHplcm9TdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcG9zc2libGVLZXk7XG4gICAgICAgICAgd2hpbGUgKHBvc3NpYmxlS2V5ID0gZmluYWxLZXlzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHtcbiAgICAgICAgICAgICAgZXhhY3RVc2VkS2V5ID0gcG9zc2libGVLZXk7XG4gICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5nZXRSZXNvdXJjZShjb2RlLCBucywgcG9zc2libGVLZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzOiBmb3VuZCxcbiAgICAgIHVzZWRLZXksXG4gICAgICBleGFjdFVzZWRLZXksXG4gICAgICB1c2VkTG5nLFxuICAgICAgdXNlZE5TXG4gICAgfTtcbiAgfVxuICBpc1ZhbGlkTG9va3VwKHJlcykge1xuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuTnVsbCAmJiByZXMgPT09IG51bGwpICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyAmJiByZXMgPT09ICcnKTtcbiAgfVxuICBnZXRSZXNvdXJjZShjb2RlLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQgJiYgdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKSByZXR1cm4gdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlU3RvcmUuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0VXNlZFBhcmFtc0RldGFpbHMoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gWydkZWZhdWx0VmFsdWUnLCAnb3JkaW5hbCcsICdjb250ZXh0JywgJ3JlcGxhY2UnLCAnbG5nJywgJ2xuZ3MnLCAnZmFsbGJhY2tMbmcnLCAnbnMnLCAna2V5U2VwYXJhdG9yJywgJ25zU2VwYXJhdG9yJywgJ3JldHVybk9iamVjdHMnLCAncmV0dXJuRGV0YWlscycsICdqb2luQXJyYXlzJywgJ3Bvc3RQcm9jZXNzJywgJ2ludGVycG9sYXRpb24nXTtcbiAgICBjb25zdCB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgdHlwZW9mIG9wdGlvbnMucmVwbGFjZSAhPT0gJ3N0cmluZyc7XG4gICAgbGV0IGRhdGEgPSB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgIGlmICh1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLmNvdW50ID0gb3B0aW9ucy5jb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgc3RhdGljIGhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ2RlZmF1bHRWYWx1ZSc7XG4gICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pICYmIHByZWZpeCA9PT0gb3B0aW9uLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAmJiB1bmRlZmluZWQgIT09IG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5jbGFzcyBMYW5ndWFnZVV0aWwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN1cHBvcnRlZExuZ3MgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdsYW5ndWFnZVV0aWxzJyk7XG4gIH1cbiAgZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHJldHVybiBudWxsO1xuICAgIHAucG9wKCk7XG4gICAgaWYgKHBbcC5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpID09PSAneCcpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwLmpvaW4oJy0nKSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gY29kZTtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwWzBdKTtcbiAgfVxuICBmb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkge1xuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgJiYgY29kZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgY29uc3Qgc3BlY2lhbENhc2VzID0gWydoYW5zJywgJ2hhbnQnLCAnbGF0bicsICdjeXJsJywgJ2NhbnMnLCAnbW9uZycsICdhcmFiJ107XG4gICAgICBsZXQgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHAgPSBwLm1hcChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzcGVjaWFsQ2FzZXMuaW5kZXhPZihwWzFdLnRvTG93ZXJDYXNlKCkpID4gLTEpIHBbMV0gPSBjYXBpdGFsaXplKHBbMV0udG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzFdLmxlbmd0aCA9PT0gMikgcFsxXSA9IHBbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBbMF0gIT09ICdzZ24nICYmIHBbMl0ubGVuZ3RoID09PSAyKSBwWzJdID0gcFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsyXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzJdID0gY2FwaXRhbGl6ZShwWzJdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAuam9pbignLScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsZWFuQ29kZSB8fCB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nID8gY29kZS50b0xvd2VyQ2FzZSgpIDogY29kZTtcbiAgfVxuICBpc1N1cHBvcnRlZENvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCA9PT0gJ2xhbmd1YWdlT25seScgfHwgdGhpcy5vcHRpb25zLm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5zdXBwb3J0ZWRMbmdzIHx8ICF0aGlzLnN1cHBvcnRlZExuZ3MubGVuZ3RoIHx8IHRoaXMuc3VwcG9ydGVkTG5ncy5pbmRleE9mKGNvZGUpID4gLTE7XG4gIH1cbiAgZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGNvZGVzKSB7XG4gICAgaWYgKCFjb2RlcykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kO1xuICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgIGNvbnN0IGNsZWFuZWRMbmcgPSB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgdGhpcy5pc1N1cHBvcnRlZENvZGUoY2xlYW5lZExuZykpIGZvdW5kID0gY2xlYW5lZExuZztcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kICYmIHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKGxuZ09ubHkpID09PSAwKSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IHRoaXMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpWzBdO1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBnZXRGYWxsYmFja0NvZGVzKGZhbGxiYWNrcywgY29kZSkge1xuICAgIGlmICghZmFsbGJhY2tzKSByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBmYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIGZhbGxiYWNrcyA9IGZhbGxiYWNrcyhjb2RlKTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ3N0cmluZycpIGZhbGxiYWNrcyA9IFtmYWxsYmFja3NdO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGZhbGxiYWNrcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHJldHVybiBmYWxsYmFja3M7XG4gICAgaWYgKCFjb2RlKSByZXR1cm4gZmFsbGJhY2tzLmRlZmF1bHQgfHwgW107XG4gICAgbGV0IGZvdW5kID0gZmFsbGJhY2tzW2NvZGVdO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3MuZGVmYXVsdDtcbiAgICByZXR1cm4gZm91bmQgfHwgW107XG4gIH1cbiAgdG9SZXNvbHZlSGllcmFyY2h5KGNvZGUsIGZhbGxiYWNrQ29kZSkge1xuICAgIGNvbnN0IGZhbGxiYWNrQ29kZXMgPSB0aGlzLmdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tDb2RlIHx8IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyB8fCBbXSwgY29kZSk7XG4gICAgY29uc3QgY29kZXMgPSBbXTtcbiAgICBjb25zdCBhZGRDb2RlID0gYyA9PiB7XG4gICAgICBpZiAoIWMpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShjKSkge1xuICAgICAgICBjb2Rlcy5wdXNoKGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcmVqZWN0aW5nIGxhbmd1YWdlIGNvZGUgbm90IGZvdW5kIGluIHN1cHBvcnRlZExuZ3M6ICR7Y31gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgJiYgKGNvZGUuaW5kZXhPZignLScpID4gLTEgfHwgY29kZS5pbmRleE9mKCdfJykgPiAtMSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScpIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JyAmJiB0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgIH1cbiAgICBmYWxsYmFja0NvZGVzLmZvckVhY2goZmMgPT4ge1xuICAgICAgaWYgKGNvZGVzLmluZGV4T2YoZmMpIDwgMCkgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShmYykpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2RlcztcbiAgfVxufVxuXG5sZXQgc2V0cyA9IFt7XG4gIGxuZ3M6IFsnYWNoJywgJ2FrJywgJ2FtJywgJ2FybicsICdicicsICdmaWwnLCAnZ3VuJywgJ2xuJywgJ21mZScsICdtZycsICdtaScsICdvYycsICdwdCcsICdwdC1CUicsICd0ZycsICd0bCcsICd0aScsICd0cicsICd1eicsICd3YSddLFxuICBucjogWzEsIDJdLFxuICBmYzogMVxufSwge1xuICBsbmdzOiBbJ2FmJywgJ2FuJywgJ2FzdCcsICdheicsICdiZycsICdibicsICdjYScsICdkYScsICdkZScsICdkZXYnLCAnZWwnLCAnZW4nLCAnZW8nLCAnZXMnLCAnZXQnLCAnZXUnLCAnZmknLCAnZm8nLCAnZnVyJywgJ2Z5JywgJ2dsJywgJ2d1JywgJ2hhJywgJ2hpJywgJ2h1JywgJ2h5JywgJ2lhJywgJ2l0JywgJ2trJywgJ2tuJywgJ2t1JywgJ2xiJywgJ21haScsICdtbCcsICdtbicsICdtcicsICduYWgnLCAnbmFwJywgJ25iJywgJ25lJywgJ25sJywgJ25uJywgJ25vJywgJ25zbycsICdwYScsICdwYXAnLCAncG1zJywgJ3BzJywgJ3B0LVBUJywgJ3JtJywgJ3NjbycsICdzZScsICdzaScsICdzbycsICdzb24nLCAnc3EnLCAnc3YnLCAnc3cnLCAndGEnLCAndGUnLCAndGsnLCAndXInLCAneW8nXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDJcbn0sIHtcbiAgbG5nczogWydheScsICdibycsICdjZ2cnLCAnZmEnLCAnaHQnLCAnaWQnLCAnamEnLCAnamJvJywgJ2thJywgJ2ttJywgJ2tvJywgJ2t5JywgJ2xvJywgJ21zJywgJ3NhaCcsICdzdScsICd0aCcsICd0dCcsICd1ZycsICd2aScsICd3bycsICd6aCddLFxuICBucjogWzFdLFxuICBmYzogM1xufSwge1xuICBsbmdzOiBbJ2JlJywgJ2JzJywgJ2NucicsICdkeicsICdocicsICdydScsICdzcicsICd1ayddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogNFxufSwge1xuICBsbmdzOiBbJ2FyJ10sXG4gIG5yOiBbMCwgMSwgMiwgMywgMTEsIDEwMF0sXG4gIGZjOiA1XG59LCB7XG4gIGxuZ3M6IFsnY3MnLCAnc2snXSxcbiAgbnI6IFsxLCAyLCA1XSxcbiAgZmM6IDZcbn0sIHtcbiAgbG5nczogWydjc2InLCAncGwnXSxcbiAgbnI6IFsxLCAyLCA1XSxcbiAgZmM6IDdcbn0sIHtcbiAgbG5nczogWydjeSddLFxuICBucjogWzEsIDIsIDMsIDhdLFxuICBmYzogOFxufSwge1xuICBsbmdzOiBbJ2ZyJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiA5XG59LCB7XG4gIGxuZ3M6IFsnZ2EnXSxcbiAgbnI6IFsxLCAyLCAzLCA3LCAxMV0sXG4gIGZjOiAxMFxufSwge1xuICBsbmdzOiBbJ2dkJ10sXG4gIG5yOiBbMSwgMiwgMywgMjBdLFxuICBmYzogMTFcbn0sIHtcbiAgbG5nczogWydpcyddLFxuICBucjogWzEsIDJdLFxuICBmYzogMTJcbn0sIHtcbiAgbG5nczogWydqdiddLFxuICBucjogWzAsIDFdLFxuICBmYzogMTNcbn0sIHtcbiAgbG5nczogWydrdyddLFxuICBucjogWzEsIDIsIDMsIDRdLFxuICBmYzogMTRcbn0sIHtcbiAgbG5nczogWydsdCddLFxuICBucjogWzEsIDIsIDEwXSxcbiAgZmM6IDE1XG59LCB7XG4gIGxuZ3M6IFsnbHYnXSxcbiAgbnI6IFsxLCAyLCAwXSxcbiAgZmM6IDE2XG59LCB7XG4gIGxuZ3M6IFsnbWsnXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDE3XG59LCB7XG4gIGxuZ3M6IFsnbW5rJ10sXG4gIG5yOiBbMCwgMSwgMl0sXG4gIGZjOiAxOFxufSwge1xuICBsbmdzOiBbJ210J10sXG4gIG5yOiBbMSwgMiwgMTEsIDIwXSxcbiAgZmM6IDE5XG59LCB7XG4gIGxuZ3M6IFsnb3InXSxcbiAgbnI6IFsyLCAxXSxcbiAgZmM6IDJcbn0sIHtcbiAgbG5nczogWydybyddLFxuICBucjogWzEsIDIsIDIwXSxcbiAgZmM6IDIwXG59LCB7XG4gIGxuZ3M6IFsnc2wnXSxcbiAgbnI6IFs1LCAxLCAyLCAzXSxcbiAgZmM6IDIxXG59LCB7XG4gIGxuZ3M6IFsnaGUnLCAnaXcnXSxcbiAgbnI6IFsxLCAyLCAyMCwgMjFdLFxuICBmYzogMjJcbn1dO1xubGV0IF9ydWxlc1BsdXJhbHNUeXBlcyA9IHtcbiAgMTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPiAxKTtcbiAgfSxcbiAgMjogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gIT0gMSk7XG4gIH0sXG4gIDM6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIDQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMik7XG4gIH0sXG4gIDU6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDAgPyAwIDogbiA9PSAxID8gMSA6IG4gPT0gMiA/IDIgOiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCA/IDMgOiBuICUgMTAwID49IDExID8gNCA6IDUpO1xuICB9LFxuICA2OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPj0gMiAmJiBuIDw9IDQgPyAxIDogMik7XG4gIH0sXG4gIDc6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgODogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiAhPSA4ICYmIG4gIT0gMTEgPyAyIDogMyk7XG4gIH0sXG4gIDk6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID49IDIpO1xuICB9LFxuICAxMDogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiA8IDcgPyAyIDogbiA8IDExID8gMyA6IDQpO1xuICB9LFxuICAxMTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSB8fCBuID09IDExID8gMCA6IG4gPT0gMiB8fCBuID09IDEyID8gMSA6IG4gPiAyICYmIG4gPCAyMCA/IDIgOiAzKTtcbiAgfSxcbiAgMTI6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgIT0gMSB8fCBuICUgMTAwID09IDExKTtcbiAgfSxcbiAgMTM6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICE9PSAwKTtcbiAgfSxcbiAgMTQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPT0gMyA/IDIgOiAzKTtcbiAgfSxcbiAgMTU6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IG4gJSAxMCA+PSAyICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMik7XG4gIH0sXG4gIDE2OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICE9PSAwID8gMSA6IDIpO1xuICB9LFxuICAxNzogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSB8fCBuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IDEpO1xuICB9LFxuICAxODogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMCA/IDAgOiBuID09IDEgPyAxIDogMik7XG4gIH0sXG4gIDE5OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMCB8fCBuICUgMTAwID4gMSAmJiBuICUgMTAwIDwgMTEgPyAxIDogbiAlIDEwMCA+IDEwICYmIG4gJSAxMDAgPCAyMCA/IDIgOiAzKTtcbiAgfSxcbiAgMjA6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAwIHx8IG4gJSAxMDAgPiAwICYmIG4gJSAxMDAgPCAyMCA/IDEgOiAyKTtcbiAgfSxcbiAgMjE6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAwID09IDEgPyAxIDogbiAlIDEwMCA9PSAyID8gMiA6IG4gJSAxMDAgPT0gMyB8fCBuICUgMTAwID09IDQgPyAzIDogMCk7XG4gIH0sXG4gIDIyOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMiA/IDEgOiAobiA8IDAgfHwgbiA+IDEwKSAmJiBuICUgMTAgPT0gMCA/IDIgOiAzKTtcbiAgfVxufTtcbmNvbnN0IG5vbkludGxWZXJzaW9ucyA9IFsndjEnLCAndjInLCAndjMnXTtcbmNvbnN0IGludGxWZXJzaW9ucyA9IFsndjQnXTtcbmNvbnN0IHN1ZmZpeGVzT3JkZXIgPSB7XG4gIHplcm86IDAsXG4gIG9uZTogMSxcbiAgdHdvOiAyLFxuICBmZXc6IDMsXG4gIG1hbnk6IDQsXG4gIG90aGVyOiA1XG59O1xuZnVuY3Rpb24gY3JlYXRlUnVsZXMoKSB7XG4gIGNvbnN0IHJ1bGVzID0ge307XG4gIHNldHMuZm9yRWFjaChzZXQgPT4ge1xuICAgIHNldC5sbmdzLmZvckVhY2gobCA9PiB7XG4gICAgICBydWxlc1tsXSA9IHtcbiAgICAgICAgbnVtYmVyczogc2V0Lm5yLFxuICAgICAgICBwbHVyYWxzOiBfcnVsZXNQbHVyYWxzVHlwZXNbc2V0LmZjXVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBydWxlcztcbn1cbmNsYXNzIFBsdXJhbFJlc29sdmVyIHtcbiAgY29uc3RydWN0b3IobGFuZ3VhZ2VVdGlscykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBsYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgncGx1cmFsUmVzb2x2ZXInKTtcbiAgICBpZiAoKCF0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gfHwgaW50bFZlcnNpb25zLmluY2x1ZGVzKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTikpICYmICh0eXBlb2YgSW50bCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUludGwuUGx1cmFsUnVsZXMpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPSAndjMnO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1lvdXIgZW52aXJvbm1lbnQgc2VlbXMgbm90IHRvIGJlIEludGwgQVBJIGNvbXBhdGlibGUsIHVzZSBhbiBJbnRsLlBsdXJhbFJ1bGVzIHBvbHlmaWxsLiBXaWxsIGZhbGxiYWNrIHRvIHRoZSBjb21wYXRpYmlsaXR5SlNPTiB2MyBmb3JtYXQgaGFuZGxpbmcuJyk7XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSBjcmVhdGVSdWxlcygpO1xuICB9XG4gIGFkZFJ1bGUobG5nLCBvYmopIHtcbiAgICB0aGlzLnJ1bGVzW2xuZ10gPSBvYmo7XG4gIH1cbiAgZ2V0UnVsZShjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLlBsdXJhbFJ1bGVzKGdldENsZWFuZWRDb2RlKGNvZGUpLCB7XG4gICAgICAgICAgdHlwZTogb3B0aW9ucy5vcmRpbmFsID8gJ29yZGluYWwnIDogJ2NhcmRpbmFsJ1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJ1bGVzW2NvZGVdIHx8IHRoaXMucnVsZXNbdGhpcy5sYW5ndWFnZVV0aWxzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpXTtcbiAgfVxuICBuZWVkc1BsdXJhbChjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICByZXR1cm4gcnVsZSAmJiBydWxlLnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGUgJiYgcnVsZS5udW1iZXJzLmxlbmd0aCA+IDE7XG4gIH1cbiAgZ2V0UGx1cmFsRm9ybXNPZktleShjb2RlLCBrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4ZXMoY29kZSwgb3B0aW9ucykubWFwKHN1ZmZpeCA9PiBgJHtrZXl9JHtzdWZmaXh9YCk7XG4gIH1cbiAgZ2V0U3VmZml4ZXMoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHJldHVybiBydWxlLnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMuc29ydCgocGx1cmFsQ2F0ZWdvcnkxLCBwbHVyYWxDYXRlZ29yeTIpID0+IHN1ZmZpeGVzT3JkZXJbcGx1cmFsQ2F0ZWdvcnkxXSAtIHN1ZmZpeGVzT3JkZXJbcGx1cmFsQ2F0ZWdvcnkyXSkubWFwKHBsdXJhbENhdGVnb3J5ID0+IGAke3RoaXMub3B0aW9ucy5wcmVwZW5kfSR7b3B0aW9ucy5vcmRpbmFsID8gYG9yZGluYWwke3RoaXMub3B0aW9ucy5wcmVwZW5kfWAgOiAnJ30ke3BsdXJhbENhdGVnb3J5fWApO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZS5udW1iZXJzLm1hcChudW1iZXIgPT4gdGhpcy5nZXRTdWZmaXgoY29kZSwgbnVtYmVyLCBvcHRpb25zKSk7XG4gIH1cbiAgZ2V0U3VmZml4KGNvZGUsIGNvdW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cnVsZS5zZWxlY3QoY291bnQpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdWZmaXhSZXRyb0NvbXBhdGlibGUocnVsZSwgY291bnQpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci53YXJuKGBubyBwbHVyYWwgcnVsZSBmb3VuZCBmb3I6ICR7Y29kZX1gKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlKHJ1bGUsIGNvdW50KSB7XG4gICAgY29uc3QgaWR4ID0gcnVsZS5ub0FicyA/IHJ1bGUucGx1cmFscyhjb3VudCkgOiBydWxlLnBsdXJhbHMoTWF0aC5hYnMoY291bnQpKTtcbiAgICBsZXQgc3VmZml4ID0gcnVsZS5udW1iZXJzW2lkeF07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeCAmJiBydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgaWYgKHN1ZmZpeCA9PT0gMikge1xuICAgICAgICBzdWZmaXggPSAncGx1cmFsJztcbiAgICAgIH0gZWxzZSBpZiAoc3VmZml4ID09PSAxKSB7XG4gICAgICAgIHN1ZmZpeCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXR1cm5TdWZmaXggPSAoKSA9PiB0aGlzLm9wdGlvbnMucHJlcGVuZCAmJiBzdWZmaXgudG9TdHJpbmcoKSA/IHRoaXMub3B0aW9ucy5wcmVwZW5kICsgc3VmZml4LnRvU3RyaW5nKCkgOiBzdWZmaXgudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OID09PSAndjEnKSB7XG4gICAgICBpZiAoc3VmZml4ID09PSAxKSByZXR1cm4gJyc7XG4gICAgICBpZiAodHlwZW9mIHN1ZmZpeCA9PT0gJ251bWJlcicpIHJldHVybiBgX3BsdXJhbF8ke3N1ZmZpeC50b1N0cmluZygpfWA7XG4gICAgICByZXR1cm4gcmV0dXJuU3VmZml4KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MicpIHtcbiAgICAgIHJldHVybiByZXR1cm5TdWZmaXgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeCAmJiBydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJldHVyblN1ZmZpeCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByZXBlbmQgJiYgaWR4LnRvU3RyaW5nKCkgPyB0aGlzLm9wdGlvbnMucHJlcGVuZCArIGlkeC50b1N0cmluZygpIDogaWR4LnRvU3RyaW5nKCk7XG4gIH1cbiAgc2hvdWxkVXNlSW50bEFwaSgpIHtcbiAgICByZXR1cm4gIW5vbkludGxWZXJzaW9ucy5pbmNsdWRlcyh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpIHtcbiAgbGV0IGtleVNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJy4nO1xuICBsZXQgaWdub3JlSlNPTlN0cnVjdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgbGV0IHBhdGggPSBnZXRQYXRoV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpO1xuICBpZiAoIXBhdGggJiYgaWdub3JlSlNPTlN0cnVjdHVyZSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBkZWVwRmluZChkYXRhLCBrZXksIGtleVNlcGFyYXRvcik7XG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgcGF0aCA9IGRlZXBGaW5kKGRlZmF1bHREYXRhLCBrZXksIGtleVNlcGFyYXRvcik7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5jbGFzcyBJbnRlcnBvbGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnaW50ZXJwb2xhdG9yJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiBvcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0IHx8ICh2YWx1ZSA9PiB2YWx1ZSk7XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICghb3B0aW9ucy5pbnRlcnBvbGF0aW9uKSBvcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICBlc2NhcGVWYWx1ZTogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgaU9wdHMgPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5lc2NhcGUgPSBpT3B0cy5lc2NhcGUgIT09IHVuZGVmaW5lZCA/IGlPcHRzLmVzY2FwZSA6IGVzY2FwZTtcbiAgICB0aGlzLmVzY2FwZVZhbHVlID0gaU9wdHMuZXNjYXBlVmFsdWUgIT09IHVuZGVmaW5lZCA/IGlPcHRzLmVzY2FwZVZhbHVlIDogdHJ1ZTtcbiAgICB0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUgPSBpT3B0cy51c2VSYXdWYWx1ZVRvRXNjYXBlICE9PSB1bmRlZmluZWQgPyBpT3B0cy51c2VSYXdWYWx1ZVRvRXNjYXBlIDogZmFsc2U7XG4gICAgdGhpcy5wcmVmaXggPSBpT3B0cy5wcmVmaXggPyByZWdleEVzY2FwZShpT3B0cy5wcmVmaXgpIDogaU9wdHMucHJlZml4RXNjYXBlZCB8fCAne3snO1xuICAgIHRoaXMuc3VmZml4ID0gaU9wdHMuc3VmZml4ID8gcmVnZXhFc2NhcGUoaU9wdHMuc3VmZml4KSA6IGlPcHRzLnN1ZmZpeEVzY2FwZWQgfHwgJ319JztcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IGlPcHRzLmZvcm1hdFNlcGFyYXRvciA/IGlPcHRzLmZvcm1hdFNlcGFyYXRvciA6IGlPcHRzLmZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy51bmVzY2FwZVByZWZpeCA9IGlPcHRzLnVuZXNjYXBlU3VmZml4ID8gJycgOiBpT3B0cy51bmVzY2FwZVByZWZpeCB8fCAnLSc7XG4gICAgdGhpcy51bmVzY2FwZVN1ZmZpeCA9IHRoaXMudW5lc2NhcGVQcmVmaXggPyAnJyA6IGlPcHRzLnVuZXNjYXBlU3VmZml4IHx8ICcnO1xuICAgIHRoaXMubmVzdGluZ1ByZWZpeCA9IGlPcHRzLm5lc3RpbmdQcmVmaXggPyByZWdleEVzY2FwZShpT3B0cy5uZXN0aW5nUHJlZml4KSA6IGlPcHRzLm5lc3RpbmdQcmVmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCckdCgnKTtcbiAgICB0aGlzLm5lc3RpbmdTdWZmaXggPSBpT3B0cy5uZXN0aW5nU3VmZml4ID8gcmVnZXhFc2NhcGUoaU9wdHMubmVzdGluZ1N1ZmZpeCkgOiBpT3B0cy5uZXN0aW5nU3VmZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnKScpO1xuICAgIHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgPSBpT3B0cy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvciA/IGlPcHRzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIDogaU9wdHMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMubWF4UmVwbGFjZXMgPSBpT3B0cy5tYXhSZXBsYWNlcyA/IGlPcHRzLm1heFJlcGxhY2VzIDogMTAwMDtcbiAgICB0aGlzLmFsd2F5c0Zvcm1hdCA9IGlPcHRzLmFsd2F5c0Zvcm1hdCAhPT0gdW5kZWZpbmVkID8gaU9wdHMuYWx3YXlzRm9ybWF0IDogZmFsc2U7XG4gICAgdGhpcy5yZXNldFJlZ0V4cCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIHJlc2V0UmVnRXhwKCkge1xuICAgIGNvbnN0IHJlZ2V4cFN0ciA9IGAke3RoaXMucHJlZml4fSguKz8pJHt0aGlzLnN1ZmZpeH1gO1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleHBTdHIsICdnJyk7XG4gICAgY29uc3QgcmVnZXhwVW5lc2NhcGVTdHIgPSBgJHt0aGlzLnByZWZpeH0ke3RoaXMudW5lc2NhcGVQcmVmaXh9KC4rPykke3RoaXMudW5lc2NhcGVTdWZmaXh9JHt0aGlzLnN1ZmZpeH1gO1xuICAgIHRoaXMucmVnZXhwVW5lc2NhcGUgPSBuZXcgUmVnRXhwKHJlZ2V4cFVuZXNjYXBlU3RyLCAnZycpO1xuICAgIGNvbnN0IG5lc3RpbmdSZWdleHBTdHIgPSBgJHt0aGlzLm5lc3RpbmdQcmVmaXh9KC4rPykke3RoaXMubmVzdGluZ1N1ZmZpeH1gO1xuICAgIHRoaXMubmVzdGluZ1JlZ2V4cCA9IG5ldyBSZWdFeHAobmVzdGluZ1JlZ2V4cFN0ciwgJ2cnKTtcbiAgfVxuICBpbnRlcnBvbGF0ZShzdHIsIGRhdGEsIGxuZywgb3B0aW9ucykge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IHJlcGxhY2VzO1xuICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMgfHwge307XG4gICAgZnVuY3Rpb24gcmVnZXhTYWZlKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXCQvZywgJyQkJCQnKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlRm9ybWF0ID0ga2V5ID0+IHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5LCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsd2F5c0Zvcm1hdCA/IHRoaXMuZm9ybWF0KHBhdGgsIHVuZGVmaW5lZCwgbG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IGtleVxuICAgICAgICB9KSA6IHBhdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0ga2V5LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgIGNvbnN0IGsgPSBwLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgY29uc3QgZiA9IHAuam9pbih0aGlzLmZvcm1hdFNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrLCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSksIGYsIGxuZywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgICBjb25zdCBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgPSBvcHRpb25zICYmIG9wdGlvbnMubWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyIHx8IHRoaXMub3B0aW9ucy5taXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXI7XG4gICAgY29uc3Qgc2tpcE9uVmFyaWFibGVzID0gb3B0aW9ucyAmJiBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyA6IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcztcbiAgICBjb25zdCB0b2RvcyA9IFt7XG4gICAgICByZWdleDogdGhpcy5yZWdleHBVbmVzY2FwZSxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHJlZ2V4U2FmZSh2YWwpXG4gICAgfSwge1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwLFxuICAgICAgc2FmZVZhbHVlOiB2YWwgPT4gdGhpcy5lc2NhcGVWYWx1ZSA/IHJlZ2V4U2FmZSh0aGlzLmVzY2FwZSh2YWwpKSA6IHJlZ2V4U2FmZSh2YWwpXG4gICAgfV07XG4gICAgdG9kb3MuZm9yRWFjaCh0b2RvID0+IHtcbiAgICAgIHJlcGxhY2VzID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHRvZG8ucmVnZXguZXhlYyhzdHIpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRWYXIgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHZhbHVlID0gaGFuZGxlRm9ybWF0KG1hdGNoZWRWYXIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyKHN0ciwgbWF0Y2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlb2YgdGVtcCA9PT0gJ3N0cmluZycgPyB0ZW1wIDogJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBtYXRjaGVkVmFyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcGFzcyBpbiB2YXJpYWJsZSAke21hdGNoZWRWYXJ9IGZvciBpbnRlcnBvbGF0aW5nICR7c3RyfWApO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlVmFsdWUgPSB0b2RvLnNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCBzYWZlVmFsdWUpO1xuICAgICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZXMrKztcbiAgICAgICAgaWYgKHJlcGxhY2VzID49IHRoaXMubWF4UmVwbGFjZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbmVzdChzdHIsIGZjKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGNsb25lZE9wdGlvbnM7XG4gICAgZnVuY3Rpb24gaGFuZGxlSGFzT3B0aW9ucyhrZXksIGluaGVyaXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNlcCA9IHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3I7XG4gICAgICBpZiAoa2V5LmluZGV4T2Yoc2VwKSA8IDApIHJldHVybiBrZXk7XG4gICAgICBjb25zdCBjID0ga2V5LnNwbGl0KG5ldyBSZWdFeHAoYCR7c2VwfVsgXSp7YCkpO1xuICAgICAgbGV0IG9wdGlvbnNTdHJpbmcgPSBgeyR7Y1sxXX1gO1xuICAgICAga2V5ID0gY1swXTtcbiAgICAgIG9wdGlvbnNTdHJpbmcgPSB0aGlzLmludGVycG9sYXRlKG9wdGlvbnNTdHJpbmcsIGNsb25lZE9wdGlvbnMpO1xuICAgICAgY29uc3QgbWF0Y2hlZFNpbmdsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goLycvZyk7XG4gICAgICBjb25zdCBtYXRjaGVkRG91YmxlUXVvdGVzID0gb3B0aW9uc1N0cmluZy5tYXRjaCgvXCIvZyk7XG4gICAgICBpZiAobWF0Y2hlZFNpbmdsZVF1b3RlcyAmJiBtYXRjaGVkU2luZ2xlUXVvdGVzLmxlbmd0aCAlIDIgPT09IDAgJiYgIW1hdGNoZWREb3VibGVRdW90ZXMgfHwgbWF0Y2hlZERvdWJsZVF1b3Rlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIG9wdGlvbnNTdHJpbmcgPSBvcHRpb25zU3RyaW5nLnJlcGxhY2UoLycvZywgJ1wiJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjbG9uZWRPcHRpb25zID0gSlNPTi5wYXJzZShvcHRpb25zU3RyaW5nKTtcbiAgICAgICAgaWYgKGluaGVyaXRlZE9wdGlvbnMpIGNsb25lZE9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uaW5oZXJpdGVkT3B0aW9ucyxcbiAgICAgICAgICAuLi5jbG9uZWRPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYGZhaWxlZCBwYXJzaW5nIG9wdGlvbnMgc3RyaW5nIGluIG5lc3RpbmcgZm9yIGtleSAke2tleX1gLCBlKTtcbiAgICAgICAgcmV0dXJuIGAke2tleX0ke3NlcH0ke29wdGlvbnNTdHJpbmd9YDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2YgY2xvbmVkT3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJyA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgbGV0IGRvUmVkdWNlID0gZmFsc2U7XG4gICAgICBpZiAobWF0Y2hbMF0uaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgIT09IC0xICYmICEvey4qfS8udGVzdChtYXRjaFsxXSkpIHtcbiAgICAgICAgY29uc3QgciA9IG1hdGNoWzFdLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSk7XG4gICAgICAgIG1hdGNoWzFdID0gci5zaGlmdCgpO1xuICAgICAgICBmb3JtYXR0ZXJzID0gcjtcbiAgICAgICAgZG9SZWR1Y2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBmYyhoYW5kbGVIYXNPcHRpb25zLmNhbGwodGhpcywgbWF0Y2hbMV0udHJpbSgpLCBjbG9uZWRPcHRpb25zKSwgY2xvbmVkT3B0aW9ucyk7XG4gICAgICBpZiAodmFsdWUgJiYgbWF0Y2hbMF0gPT09IHN0ciAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgbWlzc2VkIHRvIHJlc29sdmUgJHttYXRjaFsxXX0gZm9yIG5lc3RpbmcgJHtzdHJ9YCk7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZWR1Y2UpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXJzLnJlZHVjZSgodiwgZikgPT4gdGhpcy5mb3JtYXQodiwgZiwgb3B0aW9ucy5sbmcsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IG1hdGNoWzFdLnRyaW0oKVxuICAgICAgICB9KSwgdmFsdWUudHJpbSgpKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCB2YWx1ZSk7XG4gICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRm9ybWF0U3RyKGZvcm1hdFN0cikge1xuICBsZXQgZm9ybWF0TmFtZSA9IGZvcm1hdFN0ci50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgY29uc3QgZm9ybWF0T3B0aW9ucyA9IHt9O1xuICBpZiAoZm9ybWF0U3RyLmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgY29uc3QgcCA9IGZvcm1hdFN0ci5zcGxpdCgnKCcpO1xuICAgIGZvcm1hdE5hbWUgPSBwWzBdLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGNvbnN0IG9wdFN0ciA9IHBbMV0uc3Vic3RyaW5nKDAsIHBbMV0ubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGZvcm1hdE5hbWUgPT09ICdjdXJyZW5jeScgJiYgb3B0U3RyLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgIGlmICghZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSkgZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSA9IG9wdFN0ci50cmltKCk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXROYW1lID09PSAncmVsYXRpdmV0aW1lJyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLnJhbmdlKSBmb3JtYXRPcHRpb25zLnJhbmdlID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IG9wdFN0ci5zcGxpdCgnOycpO1xuICAgICAgb3B0cy5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgIGlmICghb3B0KSByZXR1cm47XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gb3B0LnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IHJlc3Quam9pbignOicpLnRyaW0oKS5yZXBsYWNlKC9eJyt8JyskL2csICcnKTtcbiAgICAgICAgaWYgKCFmb3JtYXRPcHRpb25zW2tleS50cmltKCldKSBmb3JtYXRPcHRpb25zW2tleS50cmltKCldID0gdmFsO1xuICAgICAgICBpZiAodmFsID09PSAnZmFsc2UnKSBmb3JtYXRPcHRpb25zW2tleS50cmltKCldID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWwgPT09ICd0cnVlJykgZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSA9IHRydWU7XG4gICAgICAgIGlmICghaXNOYU4odmFsKSkgZm9ybWF0T3B0aW9uc1trZXkudHJpbSgpXSA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0TmFtZSxcbiAgICBmb3JtYXRPcHRpb25zXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZUZvcm1hdHRlcih2YWwsIGxuZywgb3B0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IGxuZyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjYWNoZVtrZXldO1xuICAgIGlmICghZm9ybWF0dGVyKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBmbihnZXRDbGVhbmVkQ29kZShsbmcpLCBvcHRpb25zKTtcbiAgICAgIGNhY2hlW2tleV0gPSBmb3JtYXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZXIodmFsKTtcbiAgfTtcbn1cbmNsYXNzIEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdmb3JtYXR0ZXInKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG51bWJlcjogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pLFxuICAgICAgY3VycmVuY3k6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIGRhdGV0aW1lOiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIHJlbGF0aXZldGltZTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsLCBvcHQucmFuZ2UgfHwgJ2RheScpO1xuICAgICAgfSksXG4gICAgICBsaXN0OiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH1cbiAgaW5pdChzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICAgIH07XG4gICAgY29uc3QgaU9wdHMgPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5mb3JtYXRTZXBhcmF0b3IgPSBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgPyBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgOiBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICB9XG4gIGFkZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGZjO1xuICB9XG4gIGFkZENhY2hlZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcihmYyk7XG4gIH1cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQsIGxuZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtcyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtc1tvcHRpb25zLmludGVycG9sYXRpb25rZXldIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGwgPSB2YWxPcHRpb25zLmxvY2FsZSB8fCB2YWxPcHRpb25zLmxuZyB8fCBvcHRpb25zLmxvY2FsZSB8fCBvcHRpb25zLmxuZyB8fCBsbmc7XG4gICAgICAgICAgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKG1lbSwgbCwge1xuICAgICAgICAgICAgLi4uZm9ybWF0T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi52YWxPcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHRoZXJlIHdhcyBubyBmb3JtYXQgZnVuY3Rpb24gZm9yICR7Zm9ybWF0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW07XG4gICAgfSwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUGVuZGluZyhxLCBuYW1lKSB7XG4gIGlmIChxLnBlbmRpbmdbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBxLnBlbmRpbmdbbmFtZV07XG4gICAgcS5wZW5kaW5nQ291bnQtLTtcbiAgfVxufVxuY2xhc3MgQ29ubmVjdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoYmFja2VuZCwgc3RvcmUsIHNlcnZpY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IHNlcnZpY2VzLmxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdiYWNrZW5kQ29ubmVjdG9yJyk7XG4gICAgdGhpcy53YWl0aW5nUmVhZHMgPSBbXTtcbiAgICB0aGlzLm1heFBhcmFsbGVsUmVhZHMgPSBvcHRpb25zLm1heFBhcmFsbGVsUmVhZHMgfHwgMTA7XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMgPSAwO1xuICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA+PSAwID8gb3B0aW9ucy5tYXhSZXRyaWVzIDogNTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG9wdGlvbnMucmV0cnlUaW1lb3V0ID49IDEgPyBvcHRpb25zLnJldHJ5VGltZW91dCA6IDM1MDtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIGlmICh0aGlzLmJhY2tlbmQgJiYgdGhpcy5iYWNrZW5kLmluaXQpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5pbml0KHNlcnZpY2VzLCBvcHRpb25zLmJhY2tlbmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBxdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRvTG9hZCA9IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSB7fTtcbiAgICBjb25zdCB0b0xvYWRMYW5ndWFnZXMgPSB7fTtcbiAgICBjb25zdCB0b0xvYWROYW1lc3BhY2VzID0ge307XG4gICAgbGFuZ3VhZ2VzLmZvckVhY2gobG5nID0+IHtcbiAgICAgIGxldCBoYXNBbGxOYW1lc3BhY2VzID0gdHJ1ZTtcbiAgICAgIG5hbWVzcGFjZXMuZm9yRWFjaChucyA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtsbmd9fCR7bnN9YDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlbG9hZCAmJiB0aGlzLnN0b3JlLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZVtuYW1lXSA8IDApIDsgZWxzZSBpZiAodGhpcy5zdGF0ZVtuYW1lXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChwZW5kaW5nW25hbWVdID09PSB1bmRlZmluZWQpIHBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAxO1xuICAgICAgICAgIGhhc0FsbE5hbWVzcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodG9Mb2FkW25hbWVdID09PSB1bmRlZmluZWQpIHRvTG9hZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZE5hbWVzcGFjZXNbbnNdID09PSB1bmRlZmluZWQpIHRvTG9hZE5hbWVzcGFjZXNbbnNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWhhc0FsbE5hbWVzcGFjZXMpIHRvTG9hZExhbmd1YWdlc1tsbmddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmtleXModG9Mb2FkKS5sZW5ndGggfHwgT2JqZWN0LmtleXMocGVuZGluZykubGVuZ3RoKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICBwZW5kaW5nLFxuICAgICAgICBwZW5kaW5nQ291bnQ6IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCxcbiAgICAgICAgbG9hZGVkOiB7fSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdG9Mb2FkOiBPYmplY3Qua2V5cyh0b0xvYWQpLFxuICAgICAgcGVuZGluZzogT2JqZWN0LmtleXMocGVuZGluZyksXG4gICAgICB0b0xvYWRMYW5ndWFnZXM6IE9iamVjdC5rZXlzKHRvTG9hZExhbmd1YWdlcyksXG4gICAgICB0b0xvYWROYW1lc3BhY2VzOiBPYmplY3Qua2V5cyh0b0xvYWROYW1lc3BhY2VzKVxuICAgIH07XG4gIH1cbiAgbG9hZGVkKG5hbWUsIGVyciwgZGF0YSkge1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgaWYgKGVycikgdGhpcy5lbWl0KCdmYWlsZWRMb2FkaW5nJywgbG5nLCBucywgZXJyKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCBkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZVtuYW1lXSA9IGVyciA/IC0xIDogMjtcbiAgICBjb25zdCBsb2FkZWQgPSB7fTtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2gocSA9PiB7XG4gICAgICBwdXNoUGF0aChxLmxvYWRlZCwgW2xuZ10sIG5zKTtcbiAgICAgIHJlbW92ZVBlbmRpbmcocSwgbmFtZSk7XG4gICAgICBpZiAoZXJyKSBxLmVycm9ycy5wdXNoKGVycik7XG4gICAgICBpZiAocS5wZW5kaW5nQ291bnQgPT09IDAgJiYgIXEuZG9uZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhxLmxvYWRlZCkuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZFtsXSkgbG9hZGVkW2xdID0ge307XG4gICAgICAgICAgY29uc3QgbG9hZGVkS2V5cyA9IHEubG9hZGVkW2xdO1xuICAgICAgICAgIGlmIChsb2FkZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9hZGVkS2V5cy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICBpZiAobG9hZGVkW2xdW25dID09PSB1bmRlZmluZWQpIGxvYWRlZFtsXVtuXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxLmRvbmUgPSB0cnVlO1xuICAgICAgICBpZiAocS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcS5jYWxsYmFjayhxLmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcS5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdsb2FkZWQnLCBsb2FkZWQpO1xuICAgIHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcihxID0+ICFxLmRvbmUpO1xuICB9XG4gIHJlYWQobG5nLCBucywgZmNOYW1lKSB7XG4gICAgbGV0IHRyaWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGxldCB3YWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0aGlzLnJldHJ5VGltZW91dDtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWxuZy5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7XG4gICAgaWYgKHRoaXMucmVhZGluZ0NhbGxzID49IHRoaXMubWF4UGFyYWxsZWxSZWFkcykge1xuICAgICAgdGhpcy53YWl0aW5nUmVhZHMucHVzaCh7XG4gICAgICAgIGxuZyxcbiAgICAgICAgbnMsXG4gICAgICAgIGZjTmFtZSxcbiAgICAgICAgdHJpZWQsXG4gICAgICAgIHdhaXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMrKztcbiAgICBjb25zdCByZXNvbHZlciA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgIHRoaXMucmVhZGluZ0NhbGxzLS07XG4gICAgICBpZiAodGhpcy53YWl0aW5nUmVhZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy53YWl0aW5nUmVhZHMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5yZWFkKG5leHQubG5nLCBuZXh0Lm5zLCBuZXh0LmZjTmFtZSwgbmV4dC50cmllZCwgbmV4dC53YWl0LCBuZXh0LmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgJiYgZGF0YSAmJiB0cmllZCA8IHRoaXMubWF4UmV0cmllcykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlYWQuY2FsbCh0aGlzLCBsbmcsIG5zLCBmY05hbWUsIHRyaWVkICsgMSwgd2FpdCAqIDIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBmYyA9IHRoaXMuYmFja2VuZFtmY05hbWVdLmJpbmQodGhpcy5iYWNrZW5kKTtcbiAgICBpZiAoZmMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gZmMobG5nLCBucyk7XG4gICAgICAgIGlmIChyICYmIHR5cGVvZiByLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByLnRoZW4oZGF0YSA9PiByZXNvbHZlcihudWxsLCBkYXRhKSkuY2F0Y2gocmVzb2x2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVyKG51bGwsIHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZXIoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZjKGxuZywgbnMsIHJlc29sdmVyKTtcbiAgfVxuICBwcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZXMgPT09ICdzdHJpbmcnKSBsYW5ndWFnZXMgPSB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxhbmd1YWdlcyk7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJykgbmFtZXNwYWNlcyA9IFtuYW1lc3BhY2VzXTtcbiAgICBjb25zdCB0b0xvYWQgPSB0aGlzLnF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBpZiAoIXRvTG9hZC50b0xvYWQubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRvTG9hZC5wZW5kaW5nLmxlbmd0aCkgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0xvYWQudG9Mb2FkLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLmxvYWRPbmUobmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHt9LCBjYWxsYmFjayk7XG4gIH1cbiAgcmVsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcywge1xuICAgICAgcmVsb2FkOiB0cnVlXG4gICAgfSwgY2FsbGJhY2spO1xuICB9XG4gIGxvYWRPbmUobmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgdGhpcy5yZWFkKGxuZywgbnMsICdyZWFkJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHRoaXMubG9nZ2VyLndhcm4oYCR7cHJlZml4fWxvYWRpbmcgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ30gZmFpbGVkYCwgZXJyKTtcbiAgICAgIGlmICghZXJyICYmIGRhdGEpIHRoaXMubG9nZ2VyLmxvZyhgJHtwcmVmaXh9bG9hZGVkIG5hbWVzcGFjZSAke25zfSBmb3IgbGFuZ3VhZ2UgJHtsbmd9YCwgZGF0YSk7XG4gICAgICB0aGlzLmxvYWRlZChuYW1lLCBlcnIsIGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIHNhdmVNaXNzaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIGlzVXBkYXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIGxldCBjbGIgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6ICgpID0+IHt9O1xuICAgIGlmICh0aGlzLnNlcnZpY2VzLnV0aWxzICYmIHRoaXMuc2VydmljZXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnNlcnZpY2VzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBkaWQgbm90IHNhdmUga2V5IFwiJHtrZXl9XCIgYXMgdGhlIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCBrZXkgPT09ICcnKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYmFja2VuZCAmJiB0aGlzLmJhY2tlbmQuY3JlYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc1VwZGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kLmNyZWF0ZS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgICBpZiAoZmMubGVuZ3RoIDwgNikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByO1xuICAgICAgICAgIGlmIChmYy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByLnRoZW4oZGF0YSA9PiBjbGIobnVsbCwgZGF0YSkpLmNhdGNoKGNsYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYihudWxsLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsYihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBjbGIsIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIHJldHVybiB7XG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGluaXRJbW1lZGlhdGU6IHRydWUsXG4gICAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgICBkZWZhdWx0TlM6IFsndHJhbnNsYXRpb24nXSxcbiAgICBmYWxsYmFja0xuZzogWydkZXYnXSxcbiAgICBmYWxsYmFja05TOiBmYWxzZSxcbiAgICBzdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgICBub25FeHBsaWNpdFN1cHBvcnRlZExuZ3M6IGZhbHNlLFxuICAgIGxvYWQ6ICdhbGwnLFxuICAgIHByZWxvYWQ6IGZhbHNlLFxuICAgIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0cnVlLFxuICAgIGtleVNlcGFyYXRvcjogJy4nLFxuICAgIG5zU2VwYXJhdG9yOiAnOicsXG4gICAgcGx1cmFsU2VwYXJhdG9yOiAnXycsXG4gICAgY29udGV4dFNlcGFyYXRvcjogJ18nLFxuICAgIHBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzOiBmYWxzZSxcbiAgICBzYXZlTWlzc2luZzogZmFsc2UsXG4gICAgdXBkYXRlTWlzc2luZzogZmFsc2UsXG4gICAgc2F2ZU1pc3NpbmdUbzogJ2ZhbGxiYWNrJyxcbiAgICBzYXZlTWlzc2luZ1BsdXJhbHM6IHRydWUsXG4gICAgbWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICAgIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjogZmFsc2UsXG4gICAgcG9zdFByb2Nlc3M6IGZhbHNlLFxuICAgIHBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkOiBmYWxzZSxcbiAgICByZXR1cm5OdWxsOiBmYWxzZSxcbiAgICByZXR1cm5FbXB0eVN0cmluZzogdHJ1ZSxcbiAgICByZXR1cm5PYmplY3RzOiBmYWxzZSxcbiAgICBqb2luQXJyYXlzOiBmYWxzZSxcbiAgICByZXR1cm5lZE9iamVjdEhhbmRsZXI6IGZhbHNlLFxuICAgIHBhcnNlTWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICAgIGFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleTogZmFsc2UsXG4gICAgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGU6IGZhbHNlLFxuICAgIG92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGUoYXJncykge1xuICAgICAgbGV0IHJldCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JykgcmV0ID0gYXJnc1sxXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycpIHJldC5kZWZhdWx0VmFsdWUgPSBhcmdzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnc3RyaW5nJykgcmV0LnREZXNjcmlwdGlvbiA9IGFyZ3NbMl07XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBhcmdzWzNdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1szXSB8fCBhcmdzWzJdO1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgcmV0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGludGVycG9sYXRpb246IHtcbiAgICAgIGVzY2FwZVZhbHVlOiB0cnVlLFxuICAgICAgZm9ybWF0OiB2YWx1ZSA9PiB2YWx1ZSxcbiAgICAgIHByZWZpeDogJ3t7JyxcbiAgICAgIHN1ZmZpeDogJ319JyxcbiAgICAgIGZvcm1hdFNlcGFyYXRvcjogJywnLFxuICAgICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcbiAgICAgIG5lc3RpbmdQcmVmaXg6ICckdCgnLFxuICAgICAgbmVzdGluZ1N1ZmZpeDogJyknLFxuICAgICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3I6ICcsJyxcbiAgICAgIG1heFJlcGxhY2VzOiAxMDAwLFxuICAgICAgc2tpcE9uVmFyaWFibGVzOiB0cnVlXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMubnMgPSBbb3B0aW9ucy5uc107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja0xuZyA9PT0gJ3N0cmluZycpIG9wdGlvbnMuZmFsbGJhY2tMbmcgPSBbb3B0aW9ucy5mYWxsYmFja0xuZ107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja05TID09PSAnc3RyaW5nJykgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG4gIGlmIChvcHRpb25zLnN1cHBvcnRlZExuZ3MgJiYgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmluZGV4T2YoJ2NpbW9kZScpIDwgMCkge1xuICAgIG9wdGlvbnMuc3VwcG9ydGVkTG5ncyA9IG9wdGlvbnMuc3VwcG9ydGVkTG5ncy5jb25jYXQoWydjaW1vZGUnXSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gYmluZE1lbWJlckZ1bmN0aW9ucyhpbnN0KSB7XG4gIGNvbnN0IG1lbXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdCkpO1xuICBtZW1zLmZvckVhY2gobWVtID0+IHtcbiAgICBpZiAodHlwZW9mIGluc3RbbWVtXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdFttZW1dID0gaW5zdFttZW1dLmJpbmQoaW5zdCk7XG4gICAgfVxuICB9KTtcbn1cbmNsYXNzIEkxOG4gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2VydmljZXMgPSB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgdGhpcy5tb2R1bGVzID0ge1xuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICBiaW5kTWVtYmVyRnVuY3Rpb25zKHRoaXMpO1xuICAgIGlmIChjYWxsYmFjayAmJiAhdGhpcy5pc0luaXRpYWxpemVkICYmICFvcHRpb25zLmlzQ2xvbmUpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmluaXRJbW1lZGlhdGUpIHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBpbml0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZGVmYXVsdE5TICYmIG9wdGlvbnMuZGVmYXVsdE5TICE9PSBmYWxzZSAmJiBvcHRpb25zLm5zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ucy5pbmRleE9mKCd0cmFuc2xhdGlvbicpIDwgMCkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZk9wdHMgPSBnZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZPcHRzLFxuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4udHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgLi4uZGVmT3B0cy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uc1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzT25EZW1hbmQoQ2xhc3NPck9iamVjdCkge1xuICAgICAgaWYgKCFDbGFzc09yT2JqZWN0KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgQ2xhc3NPck9iamVjdCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBDbGFzc09yT2JqZWN0KCk7XG4gICAgICByZXR1cm4gQ2xhc3NPck9iamVjdDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkge1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sb2dnZXIpIHtcbiAgICAgICAgYmFzZUxvZ2dlci5pbml0KGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxvZ2dlciksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQobnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXR0ZXI7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLm1vZHVsZXMuZm9ybWF0dGVyO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gRm9ybWF0dGVyO1xuICAgICAgfVxuICAgICAgY29uc3QgbHUgPSBuZXcgTGFuZ3VhZ2VVdGlsKHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUodGhpcy5vcHRpb25zLnJlc291cmNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNlcnZpY2VzO1xuICAgICAgcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgICAgcy5yZXNvdXJjZVN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHMubGFuZ3VhZ2VVdGlscyA9IGx1O1xuICAgICAgcy5wbHVyYWxSZXNvbHZlciA9IG5ldyBQbHVyYWxSZXNvbHZlcihsdSwge1xuICAgICAgICBwcmVwZW5kOiB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yLFxuICAgICAgICBjb21wYXRpYmlsaXR5SlNPTjogdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OLFxuICAgICAgICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4XG4gICAgICB9KTtcbiAgICAgIGlmIChmb3JtYXR0ZXIgJiYgKCF0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgfHwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID09PSBkZWZPcHRzLmludGVycG9sYXRpb24uZm9ybWF0KSkge1xuICAgICAgICBzLmZvcm1hdHRlciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQoZm9ybWF0dGVyKTtcbiAgICAgICAgcy5mb3JtYXR0ZXIuaW5pdChzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPSBzLmZvcm1hdHRlci5mb3JtYXQuYmluZChzLmZvcm1hdHRlcik7XG4gICAgICB9XG4gICAgICBzLmludGVycG9sYXRvciA9IG5ldyBJbnRlcnBvbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIHMudXRpbHMgPSB7XG4gICAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogdGhpcy5oYXNMb2FkZWROYW1lc3BhY2UuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3IoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3Rvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcikge1xuICAgICAgICBzLmxhbmd1YWdlRGV0ZWN0b3IgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKTtcbiAgICAgICAgaWYgKHMubGFuZ3VhZ2VEZXRlY3Rvci5pbml0KSBzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdChzLCB0aGlzLm9wdGlvbnMuZGV0ZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KSB7XG4gICAgICAgIHMuaTE4bkZvcm1hdCA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQpO1xuICAgICAgICBpZiAocy5pMThuRm9ybWF0LmluaXQpIHMuaTE4bkZvcm1hdC5pbml0KHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IodGhpcy5zZXJ2aWNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNsYXRvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICBpZiAobS5pbml0KSBtLmluaXQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgY29uc3QgY29kZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgaWYgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbMF0gIT09ICdkZXYnKSB0aGlzLm9wdGlvbnMubG5nID0gY29kZXNbMF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBubyBsYW5ndWFnZURldGVjdG9yIGlzIHVzZWQgYW5kIG5vIGxuZyBpcyBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlQXBpID0gWydnZXRSZXNvdXJjZScsICdoYXNSZXNvdXJjZUJ1bmRsZScsICdnZXRSZXNvdXJjZUJ1bmRsZScsICdnZXREYXRhQnlMYW5ndWFnZSddO1xuICAgIHN0b3JlQXBpLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmVBcGlDaGFpbmVkID0gWydhZGRSZXNvdXJjZScsICdhZGRSZXNvdXJjZXMnLCAnYWRkUmVzb3VyY2VCdW5kbGUnLCAncmVtb3ZlUmVzb3VyY2VCdW5kbGUnXTtcbiAgICBzdG9yZUFwaUNoYWluZWQuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaW5pc2ggPSAoZXJyLCB0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgIXRoaXMuaW5pdGlhbGl6ZWRTdG9yZU9uY2UpIHRoaXMubG9nZ2VyLndhcm4oJ2luaXQ6IGkxOG5leHQgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gWW91IHNob3VsZCBjYWxsIGluaXQganVzdCBvbmNlIScpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB0aGlzLmxvZ2dlci5sb2coJ2luaXRpYWxpemVkJywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0KCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgdCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnICYmICF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBmaW5pc2gobnVsbCwgdGhpcy50LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jaGFuZ2VMYW5ndWFnZSh0aGlzLm9wdGlvbnMubG5nLCBmaW5pc2gpO1xuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgIXRoaXMub3B0aW9ucy5pbml0SW1tZWRpYXRlKSB7XG4gICAgICBsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQobG9hZCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkUmVzb3VyY2VzKGxhbmd1YWdlKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICAgIGxldCB1c2VkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjb25zdCB1c2VkTG5nID0gdHlwZW9mIGxhbmd1YWdlID09PSAnc3RyaW5nJyA/IGxhbmd1YWdlIDogdGhpcy5sYW5ndWFnZTtcbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnZnVuY3Rpb24nKSB1c2VkQ2FsbGJhY2sgPSBsYW5ndWFnZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgdGhpcy5vcHRpb25zLnBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzKSB7XG4gICAgICBpZiAodXNlZExuZyAmJiB1c2VkTG5nLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnICYmICghdGhpcy5vcHRpb25zLnByZWxvYWQgfHwgdGhpcy5vcHRpb25zLnByZWxvYWQubGVuZ3RoID09PSAwKSkgcmV0dXJuIHVzZWRDYWxsYmFjaygpO1xuICAgICAgY29uc3QgdG9Mb2FkID0gW107XG4gICAgICBjb25zdCBhcHBlbmQgPSBsbmcgPT4ge1xuICAgICAgICBpZiAoIWxuZykgcmV0dXJuO1xuICAgICAgICBpZiAobG5nID09PSAnY2ltb2RlJykgcmV0dXJuO1xuICAgICAgICBjb25zdCBsbmdzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsbmcpO1xuICAgICAgICBsbmdzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKGwgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgICAgaWYgKHRvTG9hZC5pbmRleE9mKGwpIDwgMCkgdG9Mb2FkLnB1c2gobCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICghdXNlZExuZykge1xuICAgICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgICBmYWxsYmFja3MuZm9yRWFjaChsID0+IGFwcGVuZChsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQodXNlZExuZyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByZWxvYWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnByZWxvYWQuZm9yRWFjaChsID0+IGFwcGVuZChsKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IubG9hZCh0b0xvYWQsIHRoaXMub3B0aW9ucy5ucywgZSA9PiB7XG4gICAgICAgIGlmICghZSAmJiAhdGhpcy5yZXNvbHZlZExhbmd1YWdlICYmIHRoaXMubGFuZ3VhZ2UpIHRoaXMuc2V0UmVzb2x2ZWRMYW5ndWFnZSh0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgdXNlZENhbGxiYWNrKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZWRDYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVsb2FkUmVzb3VyY2VzKGxuZ3MsIG5zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoIWxuZ3MpIGxuZ3MgPSB0aGlzLmxhbmd1YWdlcztcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5ucztcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnJlbG9hZChsbmdzLCBucywgZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIHVzZShtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYW4gdW5kZWZpbmVkIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAoIW1vZHVsZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhIHdyb25nIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdiYWNrZW5kJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmJhY2tlbmQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xvZ2dlcicgfHwgbW9kdWxlLmxvZyAmJiBtb2R1bGUud2FybiAmJiBtb2R1bGUuZXJyb3IpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sb2dnZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xhbmd1YWdlRGV0ZWN0b3InKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3RvciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnaTE4bkZvcm1hdCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5pMThuRm9ybWF0ID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdwb3N0UHJvY2Vzc29yJykge1xuICAgICAgcG9zdFByb2Nlc3Nvci5hZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSk7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2Zvcm1hdHRlcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJzNyZFBhcnR5Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLnB1c2gobW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UmVzb2x2ZWRMYW5ndWFnZShsKSB7XG4gICAgaWYgKCFsIHx8ICF0aGlzLmxhbmd1YWdlcykgcmV0dXJuO1xuICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGwpID4gLTEpIHJldHVybjtcbiAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgdGhpcy5sYW5ndWFnZXMubGVuZ3RoOyBsaSsrKSB7XG4gICAgICBjb25zdCBsbmdJbkxuZ3MgPSB0aGlzLmxhbmd1YWdlc1tsaV07XG4gICAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsbmdJbkxuZ3MpID4gLTEpIGNvbnRpbnVlO1xuICAgICAgaWYgKHRoaXMuc3RvcmUuaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zKGxuZ0luTG5ncykpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbG5nSW5MbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSBsbmc7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2luZycsIGxuZyk7XG4gICAgY29uc3Qgc2V0TG5nUHJvcHMgPSBsID0+IHtcbiAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsO1xuICAgICAgdGhpcy5sYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGwpO1xuICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKGwpO1xuICAgIH07XG4gICAgY29uc3QgZG9uZSA9IChlcnIsIGwpID0+IHtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudCguLi5hcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnQoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0TG5nID0gbG5ncyA9PiB7XG4gICAgICBpZiAoIWxuZyAmJiAhbG5ncyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IpIGxuZ3MgPSBbXTtcbiAgICAgIGNvbnN0IGwgPSB0eXBlb2YgbG5ncyA9PT0gJ3N0cmluZycgPyBsbmdzIDogdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEJlc3RNYXRjaEZyb21Db2RlcyhsbmdzKTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdG9yLmxhbmd1YWdlKSB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmNhY2hlVXNlckxhbmd1YWdlKSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuY2FjaGVVc2VyTGFuZ3VhZ2UobCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRSZXNvdXJjZXMobCwgZXJyID0+IHtcbiAgICAgICAgZG9uZShlcnIsIGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgc2V0TG5nKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKSk7XG4gICAgfSBlbHNlIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkudGhlbihzZXRMbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdChzZXRMbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMbmcobG5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGdldEZpeGVkVChsbmcsIG5zLCBrZXlQcmVmaXgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjb25zdCBmaXhlZFQgPSBmdW5jdGlvbiAoa2V5LCBvcHRzKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMiA/IF9sZW4zIC0gMiA6IDApLCBfa2V5MyA9IDI7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gMl0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBfdGhpczMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihba2V5LCBvcHRzXS5jb25jYXQocmVzdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxuZyA9IG9wdGlvbnMubG5nIHx8IGZpeGVkVC5sbmc7XG4gICAgICBvcHRpb25zLmxuZ3MgPSBvcHRpb25zLmxuZ3MgfHwgZml4ZWRULmxuZ3M7XG4gICAgICBvcHRpb25zLm5zID0gb3B0aW9ucy5ucyB8fCBmaXhlZFQubnM7XG4gICAgICBvcHRpb25zLmtleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4IHx8IGtleVByZWZpeCB8fCBmaXhlZFQua2V5UHJlZml4O1xuICAgICAgY29uc3Qga2V5U2VwYXJhdG9yID0gX3RoaXMzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcbiAgICAgIGxldCByZXN1bHRLZXk7XG4gICAgICBpZiAob3B0aW9ucy5rZXlQcmVmaXggJiYgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJlc3VsdEtleSA9IGtleS5tYXAoayA9PiBgJHtvcHRpb25zLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2t9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRLZXkgPSBvcHRpb25zLmtleVByZWZpeCA/IGAke29wdGlvbnMua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMzLnQocmVzdWx0S2V5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgbG5nID09PSAnc3RyaW5nJykge1xuICAgICAgZml4ZWRULmxuZyA9IGxuZztcbiAgICB9IGVsc2Uge1xuICAgICAgZml4ZWRULmxuZ3MgPSBsbmc7XG4gICAgfVxuICAgIGZpeGVkVC5ucyA9IG5zO1xuICAgIGZpeGVkVC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgcmV0dXJuIGZpeGVkVDtcbiAgfVxuICB0KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0b3IgJiYgdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZSguLi5hcmd1bWVudHMpO1xuICB9XG4gIGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICYmIHRoaXMudHJhbnNsYXRvci5leGlzdHMoLi4uYXJndW1lbnRzKTtcbiAgfVxuICBzZXREZWZhdWx0TmFtZXNwYWNlKG5zKSB7XG4gICAgdGhpcy5vcHRpb25zLmRlZmF1bHROUyA9IG5zO1xuICB9XG4gIGhhc0xvYWRlZE5hbWVzcGFjZShucykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuZXh0IHdhcyBub3QgaW5pdGlhbGl6ZWQnLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5sYW5ndWFnZXMgfHwgIXRoaXMubGFuZ3VhZ2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuLmxhbmd1YWdlcyB3ZXJlIHVuZGVmaW5lZCBvciBlbXB0eScsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG5nID0gb3B0aW9ucy5sbmcgfHwgdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8IHRoaXMubGFuZ3VhZ2VzWzBdO1xuICAgIGNvbnN0IGZhbGxiYWNrTG5nID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIDogZmFsc2U7XG4gICAgY29uc3QgbGFzdExuZyA9IHRoaXMubGFuZ3VhZ2VzW3RoaXMubGFuZ3VhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGxvYWROb3RQZW5kaW5nID0gKGwsIG4pID0+IHtcbiAgICAgIGNvbnN0IGxvYWRTdGF0ZSA9IHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5zdGF0ZVtgJHtsfXwke259YF07XG4gICAgICByZXR1cm4gbG9hZFN0YXRlID09PSAtMSB8fCBsb2FkU3RhdGUgPT09IDI7XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5wcmVjaGVjaykge1xuICAgICAgY29uc3QgcHJlUmVzdWx0ID0gb3B0aW9ucy5wcmVjaGVjayh0aGlzLCBsb2FkTm90UGVuZGluZyk7XG4gICAgICBpZiAocHJlUmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiBwcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1Jlc291cmNlQnVuZGxlKGxuZywgbnMpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5iYWNrZW5kIHx8IHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgJiYgIXRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxvYWROb3RQZW5kaW5nKGxuZywgbnMpICYmICghZmFsbGJhY2tMbmcgfHwgbG9hZE5vdFBlbmRpbmcobGFzdExuZywgbnMpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxvYWROYW1lc3BhY2VzKG5zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ucykge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5zID09PSAnc3RyaW5nJykgbnMgPSBbbnNdO1xuICAgIG5zLmZvckVhY2gobiA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5zLmluZGV4T2YobikgPCAwKSB0aGlzLm9wdGlvbnMubnMucHVzaChuKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZExhbmd1YWdlcyhsbmdzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAodHlwZW9mIGxuZ3MgPT09ICdzdHJpbmcnKSBsbmdzID0gW2xuZ3NdO1xuICAgIGNvbnN0IHByZWxvYWRlZCA9IHRoaXMub3B0aW9ucy5wcmVsb2FkIHx8IFtdO1xuICAgIGNvbnN0IG5ld0xuZ3MgPSBsbmdzLmZpbHRlcihsbmcgPT4gcHJlbG9hZGVkLmluZGV4T2YobG5nKSA8IDApO1xuICAgIGlmICghbmV3TG5ncy5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnByZWxvYWQgPSBwcmVsb2FkZWQuY29uY2F0KG5ld0xuZ3MpO1xuICAgIHRoaXMubG9hZFJlc291cmNlcyhlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBkaXIobG5nKSB7XG4gICAgaWYgKCFsbmcpIGxuZyA9IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCAodGhpcy5sYW5ndWFnZXMgJiYgdGhpcy5sYW5ndWFnZXMubGVuZ3RoID4gMCA/IHRoaXMubGFuZ3VhZ2VzWzBdIDogdGhpcy5sYW5ndWFnZSk7XG4gICAgaWYgKCFsbmcpIHJldHVybiAncnRsJztcbiAgICBjb25zdCBydGxMbmdzID0gWydhcicsICdzaHUnLCAnc3FyJywgJ3NzaCcsICd4YWEnLCAneWhkJywgJ3l1ZCcsICdhYW8nLCAnYWJoJywgJ2FidicsICdhY20nLCAnYWNxJywgJ2FjdycsICdhY3gnLCAnYWN5JywgJ2FkZicsICdhZHMnLCAnYWViJywgJ2FlYycsICdhZmInLCAnYWpwJywgJ2FwYycsICdhcGQnLCAnYXJiJywgJ2FycScsICdhcnMnLCAnYXJ5JywgJ2FyeicsICdhdXonLCAnYXZsJywgJ2F5aCcsICdheWwnLCAnYXluJywgJ2F5cCcsICdiYnonLCAncGdhJywgJ2hlJywgJ2l3JywgJ3BzJywgJ3BidCcsICdwYnUnLCAncHN0JywgJ3BycCcsICdwcmQnLCAndWcnLCAndXInLCAneWRkJywgJ3lkcycsICd5aWgnLCAnamknLCAneWknLCAnaGJvJywgJ21lbicsICd4bW4nLCAnZmEnLCAnanByJywgJ3BlbycsICdwZXMnLCAncHJzJywgJ2R2JywgJ3NhbScsICdja2InXTtcbiAgICBjb25zdCBsYW5ndWFnZVV0aWxzID0gdGhpcy5zZXJ2aWNlcyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMgfHwgbmV3IExhbmd1YWdlVXRpbChnZXQoKSk7XG4gICAgcmV0dXJuIHJ0bExuZ3MuaW5kZXhPZihsYW5ndWFnZVV0aWxzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGxuZykpID4gLTEgfHwgbG5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignLWFyYWInKSA+IDEgPyAncnRsJyA6ICdsdHInO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBJMThuKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICBjbG9uZUluc3RhbmNlKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gICAgY29uc3QgZm9ya1Jlc291cmNlU3RvcmUgPSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkgZGVsZXRlIG9wdGlvbnMuZm9ya1Jlc291cmNlU3RvcmU7XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAuLi57XG4gICAgICAgIGlzQ2xvbmU6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb25lID0gbmV3IEkxOG4obWVyZ2VkT3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZGVidWcgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbG9uZS5sb2dnZXIgPSBjbG9uZS5sb2dnZXIuY2xvbmUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG1lbWJlcnNUb0NvcHkgPSBbJ3N0b3JlJywgJ3NlcnZpY2VzJywgJ2xhbmd1YWdlJ107XG4gICAgbWVtYmVyc1RvQ29weS5mb3JFYWNoKG0gPT4ge1xuICAgICAgY2xvbmVbbV0gPSB0aGlzW21dO1xuICAgIH0pO1xuICAgIGNsb25lLnNlcnZpY2VzID0ge1xuICAgICAgLi4udGhpcy5zZXJ2aWNlc1xuICAgIH07XG4gICAgY2xvbmUuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgaWYgKGZvcmtSZXNvdXJjZVN0b3JlKSB7XG4gICAgICBjbG9uZS5zdG9yZSA9IG5ldyBSZXNvdXJjZVN0b3JlKHRoaXMuc3RvcmUuZGF0YSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICBjbG9uZS5zZXJ2aWNlcy5yZXNvdXJjZVN0b3JlID0gY2xvbmUuc3RvcmU7XG4gICAgfVxuICAgIGNsb25lLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihjbG9uZS5zZXJ2aWNlcywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cbiAgICAgIGNsb25lLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0pO1xuICAgIGNsb25lLmluaXQobWVyZ2VkT3B0aW9ucywgY2FsbGJhY2spO1xuICAgIGNsb25lLnRyYW5zbGF0b3Iub3B0aW9ucyA9IG1lcmdlZE9wdGlvbnM7XG4gICAgY2xvbmUudHJhbnNsYXRvci5iYWNrZW5kQ29ubmVjdG9yLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICBsYW5ndWFnZXM6IHRoaXMubGFuZ3VhZ2VzLFxuICAgICAgcmVzb2x2ZWRMYW5ndWFnZTogdGhpcy5yZXNvbHZlZExhbmd1YWdlXG4gICAgfTtcbiAgfVxufVxuY29uc3QgaW5zdGFuY2UgPSBJMThuLmNyZWF0ZUluc3RhbmNlKCk7XG5pbnN0YW5jZS5jcmVhdGVJbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2U7XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlID0gaW5zdGFuY2UuY3JlYXRlSW5zdGFuY2U7XG5jb25zdCBkaXIgPSBpbnN0YW5jZS5kaXI7XG5jb25zdCBpbml0ID0gaW5zdGFuY2UuaW5pdDtcbmNvbnN0IGxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5sb2FkUmVzb3VyY2VzO1xuY29uc3QgcmVsb2FkUmVzb3VyY2VzID0gaW5zdGFuY2UucmVsb2FkUmVzb3VyY2VzO1xuY29uc3QgdXNlID0gaW5zdGFuY2UudXNlO1xuY29uc3QgY2hhbmdlTGFuZ3VhZ2UgPSBpbnN0YW5jZS5jaGFuZ2VMYW5ndWFnZTtcbmNvbnN0IGdldEZpeGVkVCA9IGluc3RhbmNlLmdldEZpeGVkVDtcbmNvbnN0IHQgPSBpbnN0YW5jZS50O1xuY29uc3QgZXhpc3RzID0gaW5zdGFuY2UuZXhpc3RzO1xuY29uc3Qgc2V0RGVmYXVsdE5hbWVzcGFjZSA9IGluc3RhbmNlLnNldERlZmF1bHROYW1lc3BhY2U7XG5jb25zdCBoYXNMb2FkZWROYW1lc3BhY2UgPSBpbnN0YW5jZS5oYXNMb2FkZWROYW1lc3BhY2U7XG5jb25zdCBsb2FkTmFtZXNwYWNlcyA9IGluc3RhbmNlLmxvYWROYW1lc3BhY2VzO1xuY29uc3QgbG9hZExhbmd1YWdlcyA9IGluc3RhbmNlLmxvYWRMYW5ndWFnZXM7XG5cbmV4cG9ydCB7IGNoYW5nZUxhbmd1YWdlLCBjcmVhdGVJbnN0YW5jZSwgaW5zdGFuY2UgYXMgZGVmYXVsdCwgZGlyLCBleGlzdHMsIGdldEZpeGVkVCwgaGFzTG9hZGVkTmFtZXNwYWNlLCBpbml0LCBsb2FkTGFuZ3VhZ2VzLCBsb2FkTmFtZXNwYWNlcywgbG9hZFJlc291cmNlcywgcmVsb2FkUmVzb3VyY2VzLCBzZXREZWZhdWx0TmFtZXNwYWNlLCB0LCB1c2UgfTtcbiJdLCJuYW1lcyI6WyJjb25zb2xlTG9nZ2VyIiwidHlwZSIsImxvZyIsImFyZ3MiLCJvdXRwdXQiLCJ3YXJuIiwiZXJyb3IiLCJjb25zb2xlIiwiYXBwbHkiLCJMb2dnZXIiLCJjb25zdHJ1Y3RvciIsImNvbmNyZXRlTG9nZ2VyIiwib3B0aW9ucyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImluaXQiLCJwcmVmaXgiLCJsb2dnZXIiLCJkZWJ1ZyIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJmb3J3YXJkIiwiX2xlbjIiLCJfa2V5MiIsIl9sZW4zIiwiX2tleTMiLCJkZXByZWNhdGUiLCJfbGVuNCIsIl9rZXk0IiwibHZsIiwiZGVidWdPbmx5IiwiY3JlYXRlIiwibW9kdWxlTmFtZSIsImNsb25lIiwiYmFzZUxvZ2dlciIsIkV2ZW50RW1pdHRlciIsIm9ic2VydmVycyIsIm9uIiwiZXZlbnRzIiwibGlzdGVuZXIiLCJzcGxpdCIsImZvckVhY2giLCJldmVudCIsInB1c2giLCJvZmYiLCJmaWx0ZXIiLCJsIiwiZW1pdCIsImNsb25lZCIsImNvbmNhdCIsIm9ic2VydmVyIiwiZGVmZXIiLCJyZXMiLCJyZWoiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtYWtlU3RyaW5nIiwib2JqZWN0IiwiY29weSIsImEiLCJzIiwidCIsIm0iLCJnZXRMYXN0T2ZQYXRoIiwicGF0aCIsIkVtcHR5IiwiY2xlYW5LZXkiLCJrZXkiLCJpbmRleE9mIiwicmVwbGFjZSIsImNhbk5vdFRyYXZlcnNlRGVlcGVyIiwic3RhY2siLCJzaGlmdCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm9iaiIsImsiLCJzZXRQYXRoIiwibmV3VmFsdWUiLCJwdXNoUGF0aCIsImdldFBhdGgiLCJnZXRQYXRoV2l0aERlZmF1bHRzIiwiZGF0YSIsImRlZmF1bHREYXRhIiwidmFsdWUiLCJkZWVwRXh0ZW5kIiwidGFyZ2V0Iiwic291cmNlIiwib3ZlcndyaXRlIiwicHJvcCIsIlN0cmluZyIsInJlZ2V4RXNjYXBlIiwic3RyIiwiX2VudGl0eU1hcCIsImVzY2FwZSIsImNoYXJzIiwibG9va3NMaWtlT2JqZWN0UGF0aCIsIm5zU2VwYXJhdG9yIiwia2V5U2VwYXJhdG9yIiwicG9zc2libGVDaGFycyIsImMiLCJyIiwiUmVnRXhwIiwibWFwIiwiam9pbiIsIm1hdGNoZWQiLCJ0ZXN0Iiwia2kiLCJzdWJzdHJpbmciLCJkZWVwRmluZCIsInBhdGhzIiwiY3VycmVudCIsImkiLCJqIiwicCIsInNsaWNlIiwibWl4IiwiZW5kc1dpdGgiLCJqb2luZWRQYXRoIiwiZ2V0Q2xlYW5lZENvZGUiLCJjb2RlIiwiUmVzb3VyY2VTdG9yZSIsIm5zIiwiZGVmYXVsdE5TIiwiaWdub3JlSlNPTlN0cnVjdHVyZSIsImFkZE5hbWVzcGFjZXMiLCJyZW1vdmVOYW1lc3BhY2VzIiwiaW5kZXgiLCJzcGxpY2UiLCJnZXRSZXNvdXJjZSIsImxuZyIsInJlc3VsdCIsImFkZFJlc291cmNlIiwic2lsZW50IiwiYWRkUmVzb3VyY2VzIiwicmVzb3VyY2VzIiwidG9TdHJpbmciLCJhZGRSZXNvdXJjZUJ1bmRsZSIsImRlZXAiLCJwYWNrIiwicmVtb3ZlUmVzb3VyY2VCdW5kbGUiLCJoYXNSZXNvdXJjZUJ1bmRsZSIsImdldFJlc291cmNlQnVuZGxlIiwiY29tcGF0aWJpbGl0eUFQSSIsImdldERhdGFCeUxhbmd1YWdlIiwiaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zIiwibiIsImtleXMiLCJmaW5kIiwidiIsInRvSlNPTiIsInBvc3RQcm9jZXNzb3IiLCJwcm9jZXNzb3JzIiwiYWRkUG9zdFByb2Nlc3NvciIsIm1vZHVsZSIsIm5hbWUiLCJoYW5kbGUiLCJ0cmFuc2xhdG9yIiwicHJvY2Vzc29yIiwicHJvY2VzcyIsImNoZWNrZWRMb2FkZWRGb3IiLCJUcmFuc2xhdG9yIiwic2VydmljZXMiLCJjaGFuZ2VMYW5ndWFnZSIsImxhbmd1YWdlIiwiZXhpc3RzIiwiaW50ZXJwb2xhdGlvbiIsInJlc29sdmVkIiwiZXh0cmFjdEZyb21LZXkiLCJuYW1lc3BhY2VzIiwid291bGRDaGVja0Zvck5zSW5LZXkiLCJzZWVtc05hdHVyYWxMYW5ndWFnZSIsInVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yIiwidXNlckRlZmluZWROc1NlcGFyYXRvciIsIm1hdGNoIiwiaW50ZXJwb2xhdG9yIiwibmVzdGluZ1JlZ2V4cCIsInBhcnRzIiwidHJhbnNsYXRlIiwibGFzdEtleSIsIm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyIiwiaXNBcnJheSIsInJldHVybkRldGFpbHMiLCJuYW1lc3BhY2UiLCJhcHBlbmROYW1lc3BhY2VUb0NJTW9kZSIsInRvTG93ZXJDYXNlIiwidXNlZEtleSIsImV4YWN0VXNlZEtleSIsInVzZWRMbmciLCJ1c2VkTlMiLCJ1c2VkUGFyYW1zIiwiZ2V0VXNlZFBhcmFtc0RldGFpbHMiLCJyZXNVc2VkS2V5IiwicmVzRXhhY3RVc2VkS2V5IiwicmVzVHlwZSIsIm5vT2JqZWN0Iiwiam9pbkFycmF5cyIsImhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0IiwiaTE4bkZvcm1hdCIsImhhbmRsZUFzT2JqZWN0IiwicmV0dXJuT2JqZWN0cyIsInJldHVybmVkT2JqZWN0SGFuZGxlciIsInJlc1R5cGVJc0FycmF5IiwibmV3S2V5VG9Vc2UiLCJkZWVwS2V5IiwiZXh0ZW5kVHJhbnNsYXRpb24iLCJ1c2VkRGVmYXVsdCIsIm5lZWRzUGx1cmFsSGFuZGxpbmciLCJjb3VudCIsImhhc0RlZmF1bHRWYWx1ZSIsImRlZmF1bHRWYWx1ZVN1ZmZpeCIsInBsdXJhbFJlc29sdmVyIiwiZ2V0U3VmZml4IiwiZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrIiwib3JkaW5hbCIsImRlZmF1bHRWYWx1ZSIsImlzVmFsaWRMb29rdXAiLCJtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkiLCJyZXNGb3JNaXNzaW5nIiwidXBkYXRlTWlzc2luZyIsImZrIiwibG5ncyIsImZhbGxiYWNrTG5ncyIsImxhbmd1YWdlVXRpbHMiLCJnZXRGYWxsYmFja0NvZGVzIiwiZmFsbGJhY2tMbmciLCJzYXZlTWlzc2luZ1RvIiwidG9SZXNvbHZlSGllcmFyY2h5Iiwic2VuZCIsInNwZWNpZmljRGVmYXVsdFZhbHVlIiwiZGVmYXVsdEZvck1pc3NpbmciLCJtaXNzaW5nS2V5SGFuZGxlciIsImJhY2tlbmRDb25uZWN0b3IiLCJzYXZlTWlzc2luZyIsInNhdmVNaXNzaW5nUGx1cmFscyIsImdldFN1ZmZpeGVzIiwic3VmZml4IiwiYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5IiwicGFyc2VNaXNzaW5nS2V5SGFuZGxlciIsIl90aGlzIiwicGFyc2UiLCJkZWZhdWx0VmFyaWFibGVzIiwic2tpcEludGVycG9sYXRpb24iLCJza2lwT25WYXJpYWJsZXMiLCJuZXN0QmVmIiwibmIiLCJpbnRlcnBvbGF0ZSIsIm5hIiwibmVzdEFmdCIsIm5lc3QiLCJjb250ZXh0IiwicmVzZXQiLCJwb3N0UHJvY2VzcyIsInBvc3RQcm9jZXNzb3JOYW1lcyIsImFwcGx5UG9zdFByb2Nlc3NvciIsInBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkIiwiaTE4blJlc29sdmVkIiwiZm91bmQiLCJleHRyYWN0ZWQiLCJmYWxsYmFja05TIiwibmVlZHNaZXJvU3VmZml4TG9va3VwIiwic2hvdWxkVXNlSW50bEFwaSIsIm5lZWRzQ29udGV4dEhhbmRsaW5nIiwiY29kZXMiLCJ1dGlscyIsImhhc0xvYWRlZE5hbWVzcGFjZSIsImZpbmFsS2V5cyIsImFkZExvb2t1cEtleXMiLCJwbHVyYWxTdWZmaXgiLCJ6ZXJvU3VmZml4IiwicGx1cmFsU2VwYXJhdG9yIiwib3JkaW5hbFByZWZpeCIsImNvbnRleHRLZXkiLCJjb250ZXh0U2VwYXJhdG9yIiwicG9zc2libGVLZXkiLCJwb3AiLCJyZXR1cm5OdWxsIiwicmV0dXJuRW1wdHlTdHJpbmciLCJyZXNvdXJjZVN0b3JlIiwib3B0aW9uc0tleXMiLCJ1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEiLCJvcHRpb24iLCJjYXBpdGFsaXplIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJMYW5ndWFnZVV0aWwiLCJzdXBwb3J0ZWRMbmdzIiwiZ2V0U2NyaXB0UGFydEZyb21Db2RlIiwiZm9ybWF0TGFuZ3VhZ2VDb2RlIiwiZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUiLCJzcGVjaWFsQ2FzZXMiLCJsb3dlckNhc2VMbmciLCJwYXJ0IiwiY2xlYW5Db2RlIiwiaXNTdXBwb3J0ZWRDb2RlIiwibG9hZCIsIm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncyIsImdldEJlc3RNYXRjaEZyb21Db2RlcyIsImNsZWFuZWRMbmciLCJsbmdPbmx5Iiwic3VwcG9ydGVkTG5nIiwiZmFsbGJhY2tzIiwiZGVmYXVsdCIsImZhbGxiYWNrQ29kZSIsImZhbGxiYWNrQ29kZXMiLCJhZGRDb2RlIiwiZmMiLCJzZXRzIiwibnIiLCJfcnVsZXNQbHVyYWxzVHlwZXMiLCJOdW1iZXIiLCJub25JbnRsVmVyc2lvbnMiLCJpbnRsVmVyc2lvbnMiLCJzdWZmaXhlc09yZGVyIiwiemVybyIsIm9uZSIsInR3byIsImZldyIsIm1hbnkiLCJvdGhlciIsImNyZWF0ZVJ1bGVzIiwicnVsZXMiLCJzZXQiLCJudW1iZXJzIiwicGx1cmFscyIsIlBsdXJhbFJlc29sdmVyIiwiY29tcGF0aWJpbGl0eUpTT04iLCJpbmNsdWRlcyIsIkludGwiLCJQbHVyYWxSdWxlcyIsImFkZFJ1bGUiLCJnZXRSdWxlIiwiZXJyIiwibmVlZHNQbHVyYWwiLCJydWxlIiwicmVzb2x2ZWRPcHRpb25zIiwicGx1cmFsQ2F0ZWdvcmllcyIsImdldFBsdXJhbEZvcm1zT2ZLZXkiLCJzb3J0IiwicGx1cmFsQ2F0ZWdvcnkxIiwicGx1cmFsQ2F0ZWdvcnkyIiwicGx1cmFsQ2F0ZWdvcnkiLCJwcmVwZW5kIiwibnVtYmVyIiwic2VsZWN0IiwiZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlIiwiaWR4Iiwibm9BYnMiLCJNYXRoIiwiYWJzIiwic2ltcGxpZnlQbHVyYWxTdWZmaXgiLCJyZXR1cm5TdWZmaXgiLCJkZWVwRmluZFdpdGhEZWZhdWx0cyIsIkludGVycG9sYXRvciIsImZvcm1hdCIsImVzY2FwZVZhbHVlIiwiaU9wdHMiLCJ1c2VSYXdWYWx1ZVRvRXNjYXBlIiwicHJlZml4RXNjYXBlZCIsInN1ZmZpeEVzY2FwZWQiLCJmb3JtYXRTZXBhcmF0b3IiLCJ1bmVzY2FwZVByZWZpeCIsInVuZXNjYXBlU3VmZml4IiwibmVzdGluZ1ByZWZpeCIsIm5lc3RpbmdQcmVmaXhFc2NhcGVkIiwibmVzdGluZ1N1ZmZpeCIsIm5lc3RpbmdTdWZmaXhFc2NhcGVkIiwibmVzdGluZ09wdGlvbnNTZXBhcmF0b3IiLCJtYXhSZXBsYWNlcyIsImFsd2F5c0Zvcm1hdCIsInJlc2V0UmVnRXhwIiwicmVnZXhwU3RyIiwicmVnZXhwIiwicmVnZXhwVW5lc2NhcGVTdHIiLCJyZWdleHBVbmVzY2FwZSIsIm5lc3RpbmdSZWdleHBTdHIiLCJyZXBsYWNlcyIsInJlZ2V4U2FmZSIsInZhbCIsImhhbmRsZUZvcm1hdCIsImludGVycG9sYXRpb25rZXkiLCJ0cmltIiwiZiIsIm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciIsInRvZG9zIiwicmVnZXgiLCJzYWZlVmFsdWUiLCJ0b2RvIiwiZXhlYyIsIm1hdGNoZWRWYXIiLCJ0ZW1wIiwibGFzdEluZGV4IiwiY2xvbmVkT3B0aW9ucyIsImhhbmRsZUhhc09wdGlvbnMiLCJpbmhlcml0ZWRPcHRpb25zIiwic2VwIiwib3B0aW9uc1N0cmluZyIsIm1hdGNoZWRTaW5nbGVRdW90ZXMiLCJtYXRjaGVkRG91YmxlUXVvdGVzIiwiSlNPTiIsImUiLCJmb3JtYXR0ZXJzIiwiZG9SZWR1Y2UiLCJlbGVtIiwicmVkdWNlIiwicGFyc2VGb3JtYXRTdHIiLCJmb3JtYXRTdHIiLCJmb3JtYXROYW1lIiwiZm9ybWF0T3B0aW9ucyIsIm9wdFN0ciIsImN1cnJlbmN5IiwicmFuZ2UiLCJvcHRzIiwib3B0IiwicmVzdCIsImlzTmFOIiwicGFyc2VJbnQiLCJjcmVhdGVDYWNoZWRGb3JtYXR0ZXIiLCJmbiIsImNhY2hlIiwiaW52b2tlRm9ybWF0dGVyIiwic3RyaW5naWZ5IiwiZm9ybWF0dGVyIiwiRm9ybWF0dGVyIiwiZm9ybWF0cyIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiZGF0ZXRpbWUiLCJEYXRlVGltZUZvcm1hdCIsInJlbGF0aXZldGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImxpc3QiLCJMaXN0Rm9ybWF0IiwiYWRkIiwiYWRkQ2FjaGVkIiwibWVtIiwiZm9ybWF0dGVkIiwidmFsT3B0aW9ucyIsImZvcm1hdFBhcmFtcyIsImxvY2FsZSIsInJlbW92ZVBlbmRpbmciLCJxIiwicGVuZGluZyIsInBlbmRpbmdDb3VudCIsIkNvbm5lY3RvciIsImJhY2tlbmQiLCJzdG9yZSIsIndhaXRpbmdSZWFkcyIsIm1heFBhcmFsbGVsUmVhZHMiLCJyZWFkaW5nQ2FsbHMiLCJtYXhSZXRyaWVzIiwicmV0cnlUaW1lb3V0Iiwic3RhdGUiLCJxdWV1ZSIsInF1ZXVlTG9hZCIsImxhbmd1YWdlcyIsImNhbGxiYWNrIiwidG9Mb2FkIiwidG9Mb2FkTGFuZ3VhZ2VzIiwidG9Mb2FkTmFtZXNwYWNlcyIsImhhc0FsbE5hbWVzcGFjZXMiLCJyZWxvYWQiLCJsb2FkZWQiLCJlcnJvcnMiLCJkb25lIiwibG9hZGVkS2V5cyIsInJlYWQiLCJmY05hbWUiLCJ0cmllZCIsIndhaXQiLCJyZXNvbHZlciIsIm5leHQiLCJzZXRUaW1lb3V0IiwiYmluZCIsInRoZW4iLCJjYXRjaCIsInByZXBhcmVMb2FkaW5nIiwibG9hZE9uZSIsImZhbGxiYWNrVmFsdWUiLCJpc1VwZGF0ZSIsImNsYiIsImdldCIsImluaXRJbW1lZGlhdGUiLCJwcmVsb2FkIiwicGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMiLCJyZXQiLCJ0RGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1PcHRpb25zIiwibm9vcCIsImJpbmRNZW1iZXJGdW5jdGlvbnMiLCJpbnN0IiwibWVtcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsIkkxOG4iLCJtb2R1bGVzIiwiZXh0ZXJuYWwiLCJpc0luaXRpYWxpemVkIiwiaXNDbG9uZSIsImRlZk9wdHMiLCJjcmVhdGVDbGFzc09uRGVtYW5kIiwiQ2xhc3NPck9iamVjdCIsImx1IiwibGFuZ3VhZ2VEZXRlY3RvciIsImRldGVjdGlvbiIsInN0b3JlQXBpIiwic3RvcmVBcGlDaGFpbmVkIiwiZGVmZXJyZWQiLCJmaW5pc2giLCJpbml0aWFsaXplZFN0b3JlT25jZSIsImxvYWRSZXNvdXJjZXMiLCJ1c2VkQ2FsbGJhY2siLCJhcHBlbmQiLCJyZXNvbHZlZExhbmd1YWdlIiwic2V0UmVzb2x2ZWRMYW5ndWFnZSIsInJlbG9hZFJlc291cmNlcyIsInVzZSIsIkVycm9yIiwibGkiLCJsbmdJbkxuZ3MiLCJfdGhpczIiLCJpc0xhbmd1YWdlQ2hhbmdpbmdUbyIsInNldExuZ1Byb3BzIiwic2V0TG5nIiwiY2FjaGVVc2VyTGFuZ3VhZ2UiLCJhc3luYyIsImRldGVjdCIsImdldEZpeGVkVCIsImtleVByZWZpeCIsIl90aGlzMyIsImZpeGVkVCIsInJlc3VsdEtleSIsInNldERlZmF1bHROYW1lc3BhY2UiLCJsYXN0TG5nIiwibG9hZE5vdFBlbmRpbmciLCJsb2FkU3RhdGUiLCJwcmVjaGVjayIsInByZVJlc3VsdCIsImxvYWROYW1lc3BhY2VzIiwibG9hZExhbmd1YWdlcyIsInByZWxvYWRlZCIsIm5ld0xuZ3MiLCJkaXIiLCJydGxMbmdzIiwiY3JlYXRlSW5zdGFuY2UiLCJjbG9uZUluc3RhbmNlIiwiZm9ya1Jlc291cmNlU3RvcmUiLCJtZXJnZWRPcHRpb25zIiwibWVtYmVyc1RvQ29weSIsImluc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;